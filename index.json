{"project": "astropy", "project_url": "http://www.astropy.org/", "show_commit_url": "http://github.com/astropy/astropy/commit/", "hash_length": 8, "revision_to_hash": {"1845": "5621fe126f93cc41edb7df8349d9768c32a0aa70", "1891": "9847aa1412ef9ac337e7a2e8d998161d81fc4157", "3420": "3633ac14240d17151b5ff373eb6c1a5c4330329e", "3971": "f5167da0db750942aaf07983ac45300d7d2044b1", "4271": "464deeac8b4ccda25403d10107116aee9b72175f", "4335": "c416453c5984d04b03d5f8e4dfd13de966968850", "4799": "5f68a382adcf2b560cb4579b7170052f079041d2", "5768": "33c18eef38214cb1ee0d80aaecc1538906f8d4a4", "5853": "b5c5c24e042f9f87a55cb64d1d3f801037461147", "6461": "d03da6c8ec0fdf46d41074ee013286b9fc40bcd1", "8306": "f75ec69418af25250e07839914da2ce42ffcb529", "8529": "b48aa13593647e75e09dd80fac9a921be07e1a30", "8703": "40a010c79bbf355f50c62d5b719c1d1dcc2eaaf9", "8754": "fbd532ea2b51fb79e29a379a143302528ee9bc96", "10191": "5cafcd7f5cfbcc483091cc29b0dae8a7b813dc69", "11650": "e0209b9a268fa6a0c51a21ae312da1d0896eac0f", "12557": "83b72b64933dc9b0d46ab63834142afa78722cf7", "12756": "9431d6e860761329169cc6dc1f30b51aca2342bd", "12840": "15750909a2393c7c289fdc244b2e042bfd52b493", "13202": "1486b7211dbc6fcda37450517146f3cee5add1ef", "13777": "542718512637738441b4315bc8f1a98ab8499ddd", "15736": "1e72198f737d96f8076f314bbac0a7c536e2fae8", "15866": "e4cd1a71feae16cc0c3d390bcd8f040984f37c50", "16019": "d0548e3964464853083fd1ba8ae2b99056924368", "16319": "f863c9540b35be22c4e2cfc3fa0e303059bda973", "16354": "6af90360de599947262ccf454e36816c7fb66543", "16386": "b14c2e50123aafafd612a79ffb8ad69a0616f52f", "16533": "9ceec21e4c3755f52932940a35af613858e14eb9", "16934": "c36b85aedcf1f3375c6a6a32daf912a0196d8b4a", "17323": "ad70fbb74782369b537bbe8959034f2e4dae9dcb", "17418": "27fb98c9d0a549556cb9f13f3df4a9d309e5a7ca", "17970": "5ee3237058432ce4faea04f58f6021d72c6c44b4", "18240": "9fb669b12116b1624737406757ac5daca7fbae02", "19084": "77280d6f110d1de6f0870fce1afb8d1b608bd7a7", "19245": "af9bd871c3c610045ac9382ab4148e8ff9d88bcc", "19361": "4d8d983263038888daf300ba468055285f6b5a50", "19616": "a84ed343fd51ad9cec01446c0e0fd2bec1bdad11", "19718": "a33bc52d2e472ad4e1e2d57357eedade6efc57da", "19742": "94d462ab82db1f65b4ffeda77ca76cae3f234862", "19777": "b11dbbf5928d4835cd346ce9b1725c8e2df99e1b", "19955": "80e5c3a4fcf51bc5b8226723775118bd2641e709", "19961": "6529f253aa10a19f6da58868299392034173c1c0", "20665": "e4e2951f278d667d48889cf0ed9077b9ae038a06", "20668": "6f96c4cefdc57e1d2ca8ae83838e900853d8d7bf", "21195": "8d70ecc0dbd36366b55a2965ac959e7e8baef2d6", "21779": "a0fe8ce96c6d8ac5e4bbf9661efaf356bed7eb11", "22121": "16050625afb539a506fc3e151d4df1bccad7773d", "22211": "b864442793d90e4b73a5fbfd63a0b37e2242e963", "22331": "b0d4d775e223f769aeac01d9cff227f5fc2489d7", "22365": "18008f3b7fca47c02ae9c2f7c357cc943689c053", "22431": "652094458e745540f41dd0402a1a77823b8aab9a", "23709": "3dfdf3ea2d681b9ec3383b72cbb00bcc421acd47", "23893": "cf064b5c3d674d2b7554fc339a4a65ac527bc34c", "23894": "fa194c0e12306554db41d96e38b030f93a2f16a7", "23895": "552a2de83e23b89192a91b423eb69d35ef5424df", "24457": "bc8bccced94407b42f843074a2482be03da62b74", "24494": "a98d386f4d2715cdfd475385bc2824cd17173535", "24606": "698ea94934068163e79ee2d632152aabc72611f3", "25097": "9910521a1c1680e1a25e43c1e21fd3fc66245321", "25102": "7c6752495d1320efc7b1994e15cbcccd6e6d0b16", "26281": "c62226a6b42c3dacd4fe59348fd5f4282d0a76eb", "26459": "35ef7fd46e81e2b787e6b849a0aa011a8805c02b", "26582": "640261b2de54562b92b447d75c44252545d4dfae", "26928": "93f7e758ee3113f83a150cc98ce52c1eb894b16e", "28448": "4ea556e14340760bd58e53ea2cbccde7ce5567c3", "28777": "91fe01bc3c0cebfb7525d430ef806562ab2d3024", "29020": "525b95febac57df51506b97267e848f254db8d05", "29163": "6cb6edc89b80fe417f65286167dc2db61a885ebc", "29266": "baffe7dc107a3f1445b44479a0aab9553db0c527", "29453": "c66cd977e16fc7b42fce9dce5ccb6ddcc708ca2b", "29457": "d73dccb96099e9da4f6a877661a62c1c884dea62", "29743": "749ee4a01a86f74f8ffe5d837941f6b17f595bbb", "29745": "275807902cc62b5426b3a2a484ae4861e4c11b6e", "30057": "d6fc1577234f308103650dfe2deb652891805941", "30061": "1a2ca12afac85b7a0376831422ff6b1c1b5ed45e", "30555": "ca01b3bb62d07d938a526dbee6ff875d9917a9c9", "30558": "b24b87fc847e568c7389350d2d1deb7ca5ed9455", "31413": "71bfbaf593761e5934293502f896528846980f80", "31414": "df4c75aa2013af9537412f2306c47e480ca71fb3", "32948": "3db76a460c8ee55f68100bed880887526cc13dd9", "33013": "2ed73b0343c9e63fd1be8eb25cfe229901c78327", "33053": "743055cada122d6da8704ad28452806690679ef5", "33056": "7f6b1f2fc8b015750af50a54ae3f70934d1fe535", "33116": "d044049b9811eb4ff97a7ad8684c9b3efdb02ca6", "33122": "63355d3d334b7d8c05cd517a8edfaca07ccfb65b", "33250": "e2d0f0276d484fa4852b0a16c4944fa1076f0fbd", "33254": "072b1655d9985e3126c77fab7c1e3010f20659a2", "33916": "7bd54cad66d29886dff8e896d103810e2d563baa", "34138": "db1336313c3a7cca12184beb7224e4e93db3133a", "34190": "89b6be94196e51a45d56a23b03e1bff9f74b89b9", "34205": "7944b5b7ae4f13079519fff0d4f9e5f7e7ee4b01", "34381": "8f16141c39092dfeb597b0f380f516516ce9c5f4", "34385": "3c27d0619e05ab4289587b61197f2b0b6ec38288", "36691": "01b5fab9a49a378a0372a9102646ef512a043d1b", "37721": "6c76e90136f960dd25f185511d4eaf092e90dbc4", "37749": "bc6779fd4e6e174242a7fae599f7c42d2d60d0d5", "37836": "f8b3f30f552ac5566e9d45a3db18dfa34b94469e", "37854": "b70ce8748b03f60a14c2fe9fdd17b88aa89851e5", "37912": "219a3d40c33d4a812d84ac7b7cc54005a1ff8d63", "37981": "d88eee5014695e2bc5cadb14d492e42d77fd0f17", "38008": "763f069058cb1ee2038fa1cfa485452ec94b726e", "38215": "bedf510ca39faf66afcc3005ba3d3e34d77f443b", "38238": "143700bb2423013bdd450a2ce4b5c436f244ba6a", "38891": "e85064210d094d722e4ecb415884b967322d8cd6", "39087": "26daaf6a9915266e703827908046ea66e875759f", "39689": "53e4d45aa5a6d9effec61cdf7336e259e2aaf015", "40095": "c20b732a12cd3b06cc639238788207090a34e865", "40216": "35bd9e80307426062fc53ad93dea0834a373599d", "40349": "0b75d7fe054677840b1890c795a81f69bd3067a0", "40538": "13b473482b015417b06525056e4b3e9b715b76af", "40685": "2bdbe28ee8b047a2043fd6a3582c587a00e298f7", "40938": "3edb7e30144dd2f4dae744069df3a6b24d3cfa30", "40952": "01369fb9d230480220dd81813f3fff906f88d52d", "41693": "f6339626a47981137a469481997752a239188bc7", "41724": "e8556124037246c7fea12fce919dff7b7d6964ea", "42948": "4cc5a0a04109759c798df7ec3234e52a04afe684", "43317": "8ea8876d375a7105308e695e881330487924a154", "43691": "9f2c27e49b22f35fba04725fc4cd54b0300838cb", "43693": "2480f8b8bb0c1d2155fbc8c6dfd07f58ec4fc15a", "43805": "b17655f0f55f61f4c54fbe2c546a8854ddf1ef19", "43983": "37befe36bbf31f1bda45e9d5dd2390278dc79259", "44612": "2885b2d65a080f422ee8e6e99e2e2026e3c8bbeb", "44668": "737761cabd395c3e24f38437f2494eb521c1c990", "44843": "1c3b341adfdd7d6fc0b8eb9b17fb4ba75e96370e", "44898": "d1e122dd996d885f742a33d75d38529307294baf", "45487": "776803f1de21fe3e66ee05e7474dc43beb48a10d", "45749": "9273cc0e3636d3e8fa73d98f3a2730d1a02c27e2", "45876": "0714c0ffc92f24aa0afd6f278844a694245cc58f", "45947": "326435449ad8d859f1abf36800c3fb88d49c27ea", "46313": "f81ba85db66a37617cd88d3e6fd91b13c0945fe8", "46363": "9e8024bb2f1a52b7efe5ad4f51bf11c04569d1c8", "46507": "c375a43e8878d304d22381cac7bce4947c23ae25", "47703": "d30fbc82d028332e5cebabeebeffec7429ac50dc", "47737": "0c2784cb472bd19459a346ca5d581dd80353c28f", "48026": "628960658895340c304fc3b768835998b520c996", "48141": "fae87eeba4465abeea49703ba72ebee067955744", "48279": "cd4c7a0dc05103257bc57778b21ef84754ebce63", "48532": "95df21d0a882d36417eedabc7588c2077f314600"}, "revision_to_date": {"1845": 1339747303000, "1891": 1340086193000, "3420": 1356381732000, "3971": 1359508111000, "4271": 1360776151000, "4335": 1361312808000, "4799": 1365018342000, "5768": 1369169818000, "5853": 1369943695000, "6461": 1374690436000, "8306": 1382718598000, "8529": 1383542385000, "8703": 1384388274000, "8754": 1384996150000, "10191": 1393955310000, "11650": 1399997164000, "12557": 1404233912000, "12756": 1405176393000, "12840": 1405527129000, "13202": 1407512129000, "13777": 1411505522000, "15736": 1421359827000, "15866": 1421872215000, "16019": 1422393779000, "16319": 1423719738000, "16354": 1424120269000, "16386": 1424300515000, "16533": 1425685108000, "16934": 1429198007000, "17323": 1432928678000, "17418": 1433528685000, "17970": 1437417168000, "18240": 1439307436000, "19084": 1444080209000, "19245": 1444946629000, "19361": 1445556240000, "19616": 1448388229000, "19718": 1449272685000, "19742": 1449529967000, "19777": 1449865372000, "19955": 1452285116000, "19961": 1452286326000, "20665": 1457590190000, "20668": 1457590302000, "21195": 1462549586000, "21779": 1464093512000, "22121": 1465491754000, "22211": 1465661670000, "22331": 1466374411000, "22365": 1466621829000, "22431": 1467560102000, "23709": 1481613569000, "23893": 1482471121000, "23894": 1482471124000, "23895": 1482471126000, "24457": 1488739890000, "24494": 1489807819000, "24606": 1490907602000, "25097": 1496087607000, "25102": 1496090120000, "26281": 1498585814000, "26459": 1499381359000, "26582": 1501435147000, "26928": 1504882086000, "28448": 1513102147000, "28777": 1515369996000, "29020": 1516925005000, "29163": 1517877500000, "29266": 1518716197000, "29453": 1520873834000, "29457": 1520878715000, "29743": 1524501775000, "29745": 1524502939000, "30057": 1527887969000, "30061": 1527889449000, "30555": 1533161528000, "30558": 1533163502000, "31413": 1539802596000, "31414": 1539802596000, "32948": 1542313528000, "33013": 1543384592000, "33053": 1544067015000, "33056": 1543984980000, "33116": 1546249832000, "33122": 1546287022000, "33250": 1550904762000, "33254": 1550906140000, "33916": 1557198301000, "34138": 1559239556000, "34190": 1559940287000, "34205": 1560194831000, "34381": 1560562610000, "34385": 1560564933000, "36691": 1573421174000, "37721": 1570417998000, "37749": 1570486640000, "37836": 1572147127000, "37854": 1572149656000, "37912": 1574130179000, "37981": 1575746558000, "38008": 1576270277000, "38215": 1585289321000, "38238": 1585822867000, "38891": 1588654152000, "39087": 1590421074000, "39689": 1597958950000, "40095": 1602343415000, "40216": 1602666680000, "40349": 1603306549000, "40538": 1603767523000, "40685": 1604666278000, "40938": 1606280772000, "40952": 1606286746000, "41693": 1616786889000, "41724": 1617294608000, "42948": 1620053017000, "43317": 1624032072000, "43691": 1627313684000, "43693": 1627328495000, "43805": 1628710774000, "43983": 1629805119000, "44612": 1635629034000, "44668": 1635868293000, "44843": 1636583865000, "44898": 1637330175000, "45487": 1643235765000, "45749": 1646915970000, "45876": 1648169583000, "45947": 1648736945000, "46313": 1650749437000, "46363": 1651138634000, "46507": 1653396879000, "47703": 1666303876000, "47737": 1666512284000, "48026": 1668632242000, "48141": 1669874043000, "48279": 1670842455000, "48532": 1673038946000}, "params": {"branch": ["main"]}, "graph_param_list": [], "benchmarks": {"convolve.Convolve.time_convolve": {"code": "class Convolve:\n    def time_convolve(self, ndim, size, boundary, nan_treatment):\n        convolve(self.array, self.kernel,\n                 boundary=boundary, nan_treatment=nan_treatment)\n\n    def setup(self, ndim, size, boundary, nan_treatment):\n    \n        print(ndim, size, boundary, nan_treatment)\n    \n        np.random.seed(12345)\n    \n        self.kernel = np.random.random(kernel_shapes[ndim][size])\n        self.array = np.random.random(array_shapes[ndim][size])", "min_run_count": 2, "name": "convolve.Convolve.time_convolve", "number": 0, "param_names": ["ndim", "size", "boundary", "nan_treatment"], "params": [["1", "2", "3"], ["'small'", "'large'"], ["None", "'fill'", "'wrap'", "'extend'"], ["'fill'", "'interpolate'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bf12ed205920e07473cfcf596eaeff59930bddb209c94f98948c2a4bb78c9e4f", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_concatenate_array": {"code": "class FrameBenchmarks:\n    def time_concatenate_array(self):\n        concatenate((self.icrs_array, self.icrs_array))\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_concatenate_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d9a8a1af0db07cab1ff7ab7f030eb466efc714e0b77a879085390d16d024300d", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_concatenate_scalar": {"code": "class FrameBenchmarks:\n    def time_concatenate_scalar(self):\n        concatenate((self.icrs_scalar, self.icrs_scalar))\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_concatenate_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "377a566e5922e38093d3816db9b6d23411e8bc0968bf8bb3615a19cecd7acca1", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_coord_match_clusters": {"code": "class FrameBenchmarks:\n    def time_coord_match_clusters(self):\n        match_coordinates_sky(self.icrs_clustered1, self.icrs_clustered2)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_coord_match_clusters", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8c8d4504cba309fa1df25d7ebcc9011afbe10b7a8ae72bf2895372144fd5c296", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_coord_match_sphere": {"code": "class FrameBenchmarks:\n    def time_coord_match_sphere(self):\n        match_coordinates_sky(self.icrs_uniform_sph1, self.icrs_uniform_sph2)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_coord_match_sphere", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3564f883f404bd6d53a21b9e3334ff6ce6af97655e2550fd6c6ef7825f59eb88", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_coord_match_uniform": {"code": "class FrameBenchmarks:\n    def time_coord_match_uniform(self):\n        match_coordinates_sky(self.icrs_uniform1, self.icrs_uniform2)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_coord_match_uniform", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a094f6cec6d6468375e50b362b7bab22b093aba20c9a464a3d72adaae21d1c0a", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_init_array": {"code": "class FrameBenchmarks:\n    def time_init_array(self):\n        FK5(self.array_ra, self.array_dec)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_init_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9dd0a9af08100d43cbb44afb12957e4a62200628da9d4f8e69396e3aedfe22ca", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_init_nodata": {"code": "class FrameBenchmarks:\n    def time_init_nodata(self):\n        FK5()\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_init_nodata", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3de6a4d1c00c390fc1c099914a2ba625d79fc4c85f45592bf67bb8e535b38e42", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_init_scalar": {"code": "class FrameBenchmarks:\n    def time_init_scalar(self):\n        FK5(self.scalar_ra, self.scalar_dec)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_init_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "64b79a07d8ce0eea2f8be87c1422b9915b414f7e640810bd427f81733a684c99", "warmup_time": -1}, "coordinates.FrameBenchmarks.time_init_scalar_diff": {"code": "class FrameBenchmarks:\n    def time_init_scalar_diff(self):\n        FK5(self.scalar_ra, self.scalar_dec,\n            pm_ra_cosdec=self.scalar_pmra,\n            pm_dec=self.scalar_pmdec)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.scalar_pmra = 3.2 * u.mas/u.yr\n        self.scalar_pmdec = 2.2 * u.mas/u.yr\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg\n    \n        np.random.seed(12345)\n        self.icrs_scalar = ICRS(ra=1*u.deg, dec=2*u.deg)\n        self.icrs_array = ICRS(ra=np.random.random(10000)*u.deg,\n                               dec=np.random.random(10000)*u.deg)\n    \n        # Some points to use for benchmarking coordinate matching.\n        # These were motivated by some tests done in astropy/astropy#7324:\n        # https://github.com/astropy/astropy/pull/7324#issuecomment-392382719\n        xyz_uniform1 = rnd.uniform(size=(3, 10000)) * u.kpc\n        xyz_uniform2 = rnd.uniform(size=(3, 10000)) * u.kpc\n        self.icrs_uniform1 = ICRS(xyz_uniform1,\n                                  representation_type=CartesianRepresentation)\n        self.icrs_uniform2 = ICRS(xyz_uniform2,\n                                  representation_type=CartesianRepresentation)\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph1 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n    \n        phi = rnd.uniform(0, 2*np.pi, size=10000)\n        theta = np.arccos(2*rnd.uniform(size=10000) - 1)\n        xyz_uniform_sph2 = np.vstack((np.cos(phi)*np.sin(theta),\n                                      np.sin(phi)*np.sin(theta),\n                                      np.cos(theta))) * u.kpc\n        self.icrs_uniform_sph1 = ICRS(\n            xyz_uniform_sph1, representation_type=CartesianRepresentation)\n        self.icrs_uniform_sph2 = ICRS(\n            xyz_uniform_sph2, representation_type=CartesianRepresentation)\n    \n        xyz0 = rnd.uniform(-100, 100, size=(8, 3))\n        xyz_clustered1 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        xyz_clustered2 = np.vstack(rnd.normal(xyz0, size=(10000, 8, 3))).T * u.kpc\n        self.icrs_clustered1 = ICRS(\n            xyz_clustered1, representation_type=CartesianRepresentation)\n        self.icrs_clustered2 = ICRS(\n            xyz_clustered2, representation_type=CartesianRepresentation)", "min_run_count": 2, "name": "coordinates.FrameBenchmarks.time_init_scalar_diff", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7661b4eb62bd7efea9dc2bb5bc4af216cd23919eca3a415675d2cebe4f0b4e4d", "warmup_time": -1}, "coordinates.RepresentationBenchmarks.time_with_differentials_array": {"code": "class RepresentationBenchmarks:\n    def time_with_differentials_array(self):\n        self.array_rep.with_differentials(self.array_dif)\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.coordinates import CartesianDifferential\n    \n        self.scalar_rep = CartesianRepresentation([1., 2, 3] * u.kpc)\n        self.scalar_dif = CartesianDifferential([1, 2, 3.] * u.km/u.s)\n    \n        self.array_rep = CartesianRepresentation(np.ones((3, 1000)) * u.kpc)\n        self.array_dif = CartesianDifferential(np.ones((3, 1000)) * u.km/u.s)", "min_run_count": 2, "name": "coordinates.RepresentationBenchmarks.time_with_differentials_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ea5b8a8d6522a15a7037a7e20517f65435da8b1962d1fc28da1fcca6400226d8", "warmup_time": -1}, "coordinates.RepresentationBenchmarks.time_with_differentials_scalar": {"code": "class RepresentationBenchmarks:\n    def time_with_differentials_scalar(self):\n        self.scalar_rep.with_differentials(self.scalar_dif)\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.coordinates import CartesianDifferential\n    \n        self.scalar_rep = CartesianRepresentation([1., 2, 3] * u.kpc)\n        self.scalar_dif = CartesianDifferential([1, 2, 3.] * u.km/u.s)\n    \n        self.array_rep = CartesianRepresentation(np.ones((3, 1000)) * u.kpc)\n        self.array_dif = CartesianDifferential(np.ones((3, 1000)) * u.km/u.s)", "min_run_count": 2, "name": "coordinates.RepresentationBenchmarks.time_with_differentials_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e5b3b94e549e3d9ebf56b77e0023426d9f175091679bddb5f381414aeed2fd4b", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_array": {"code": "class SkyCoordBenchmarks:\n    def time_icrs_to_galactic_array(self):\n        self.coord_array_1e6.transform_to('galactic')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6918c6ca278f7e282233d1a613a666e12d3db465f97f3f943077ff24883c0102", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_scalar": {"code": "class SkyCoordBenchmarks:\n    def time_icrs_to_galactic_scalar(self):\n        self.coord_scalar.transform_to('galactic')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4371461be3fbec6d1e2eb85c480e89ebb05c1a4d3b23f3e9442445264c770f95", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_array": {"code": "class SkyCoordBenchmarks:\n    def time_init_array(self):\n        SkyCoord(self.lon_1e6, self.lat_1e6, unit='deg', frame='icrs')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "273c7b66248421d01e454afe76c992ac13ee8da5d53b31230bf44817582b4957", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_array_keyword": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_array_keyword(self):\n        SkyCoord(ra=self.array_q_ra, dec=self.array_q_dec)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_array_keyword", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "228c3b5290e1a7523e150ace3755c584231f7fc3f5de85a3e148e3ad6d079d56", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_array_positional": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_array_positional(self):\n        SkyCoord(self.array_q_ra, self.array_q_dec)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_array_positional", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "84d91d570508630e25dcc267565c57ce6f9190479df1c663121c736a0d6c15f1", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_keyword": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_scalar_keyword(self):\n        SkyCoord(ra=self.scalar_q_ra, dec=self.scalar_q_dec)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_keyword", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6348fe2890a5b4473195b1f7563c87ad57f2bdefb89ea98f5100a6ada7d06e9e", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_scalar_positional(self):\n        SkyCoord(self.scalar_q_ra, self.scalar_q_dec)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3ca05a73377c056edac1cd48846b6936f47895cef3b380972da0c85ae3d5f587", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_frame": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_scalar_positional_fk5_frame(self):\n        SkyCoord(self.scalar_q_ra, self.scalar_q_dec,\n                 frame=fk5_J2010)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_frame", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a4efb71d10727b763b5a7c811925b0d9465dfcf14ff3982051fc00083d67d6d2", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_frame_extra_kwargs": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_scalar_positional_fk5_frame_extra_kwargs(self):\n        SkyCoord(self.scalar_q_ra, self.scalar_q_dec,\n                 frame=fk5_J2010, obstime=J2010)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_frame_extra_kwargs", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "154c9dc8471faafe661a677aac2b53617f884f3bd5c477a703c4946bb6c71eea", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_kwarg": {"code": "class SkyCoordBenchmarks:\n    def time_init_quantity_scalar_positional_fk5_kwarg(self):\n        SkyCoord(self.scalar_q_ra, self.scalar_q_dec,\n                 frame='fk5', equinox=J2010)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_quantity_scalar_positional_fk5_kwarg", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ae5bff79320c7ca0bc37bc9acb491b50e2e15e79608cc4115d485458bcdfdce5", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_repr_array_noframe": {"code": "class SkyCoordBenchmarks:\n    def time_init_repr_array_noframe(self):\n        SkyCoord(self.array_repr)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_repr_array_noframe", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eefda7caa996d6ea6f20de39e85eca14ee2923e68b15e61739d8aed4ac276d67", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_repr_scalar_noframe": {"code": "class SkyCoordBenchmarks:\n    def time_init_repr_scalar_noframe(self):\n        SkyCoord(self.scalar_repr)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_repr_scalar_noframe", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ebda1373d9d66ea63bbd9978e45706c205eb72d3caa32b8cec944aa56833127", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_init_scalar": {"code": "class SkyCoordBenchmarks:\n    def time_init_scalar(self):\n        SkyCoord(1, 2, unit='deg', frame='icrs')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_init_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0685d7303c02a13f2e42eb6f13a8752c049f4638b7c54b60aefda722119a1664", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_iter_array": {"code": "class SkyCoordBenchmarks:\n    def time_iter_array(self):\n        for c in self.coord_array_1e3:\n            pass\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_iter_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1adc399feb7e9134018548bf35fb5f2d6715353410a37ab1aeb0f1db8709a905", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_repr_array": {"code": "class SkyCoordBenchmarks:\n    def time_repr_array(self):\n        repr(self.coord_array_1e3)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_repr_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6a31bf4c63967f9cc612e423d27ee13dcade1c4cdcd51c8c8c74715bebd5eab8", "warmup_time": -1}, "coordinates.SkyCoordBenchmarks.time_repr_scalar": {"code": "class SkyCoordBenchmarks:\n    def time_repr_scalar(self):\n        repr(self.coord_scalar)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones((2, 1000))\n        self.coord_array_1e3 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        self.lon_1e6, self.lat_1e6 = np.ones((2, int(1e6)))\n        self.coord_array_1e6 = SkyCoord(self.lon_1e6, self.lat_1e6,\n                                        unit='deg', frame='icrs')\n    \n        self.scalar_q_ra = 1 * u.deg\n        self.scalar_q_dec = 2 * u.deg\n    \n        np.random.seed(12345)\n        self.array_q_ra = np.random.rand(int(1e6)) * 360 * u.deg\n        self.array_q_dec = (np.random.rand(int(1e6)) * 180 - 90) * u.deg\n    \n        self.scalar_repr = UnitSphericalRepresentation(lat=self.scalar_q_dec,\n                                                       lon=self.scalar_q_ra)\n        self.array_repr = UnitSphericalRepresentation(lat=self.array_q_dec,\n                                                      lon=self.array_q_ra)", "min_run_count": 2, "name": "coordinates.SkyCoordBenchmarks.time_repr_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9049bec253bea2f918e9cca490d39804c1d067babefbfc0c16b508455abff8e4", "warmup_time": -1}, "coordinates.time_angle_array_repr": {"code": "def time_angle_array_repr():\n    # Prior to Astropy 3.0, this was very inefficient\n    repr(ANGLES)", "min_run_count": 2, "name": "coordinates.time_angle_array_repr", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f7358d7eaaa2c43a08c409093a9da4c8824ee2c56f680a47906562bb1ce67d7c", "warmup_time": -1}, "coordinates.time_angle_array_repr_latex": {"code": "def time_angle_array_repr_latex():\n    # Prior to Astropy 3.0, this was very inefficient\n    ANGLES._repr_latex_()", "min_run_count": 2, "name": "coordinates.time_angle_array_repr_latex", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d791293d91b6bf48d25ec937a4650655e13e232dd2136182811357cc4641fdef", "warmup_time": -1}, "coordinates.time_angle_array_str": {"code": "def time_angle_array_str():\n    # Prior to Astropy 3.0, this was very inefficient\n    str(ANGLES)", "min_run_count": 2, "name": "coordinates.time_angle_array_str", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bb01074796e6a03b8b0c30b44045048769af753ecbe7b2ec8bf460be6bb73160", "warmup_time": -1}, "coordinates.time_latitude": {"code": "def time_latitude():\n    Latitude(3.2, u.degree)", "min_run_count": 2, "name": "coordinates.time_latitude", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d37e722e0c0f585281e1f368dc32f3943dd8cf1ec4009924181467dd2c3a6cd0", "warmup_time": -1}, "cosmology.LambdaCDMBenchmarks.time_age": {"code": "class LambdaCDMBenchmarks:\n    def time_age(self, cosmo):\n        self.cosmology.age(self.test_zs)\n\n    def setup(self, cosmo):\n        self.cosmology = cosmo\n        self.test_zs = np.linspace(0.1, 5.0, 200)", "min_run_count": 2, "name": "cosmology.LambdaCDMBenchmarks.time_age", "number": 0, "param_names": ["param1"], "params": [["LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=0.0 K, Neff=3.04, m_nu=None, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Ode0=0.65, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=2.7 K, Neff=4.0, m_nu=[0. 0. 0. 0.] eV, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.4, Ode0=0.2, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=0.0 K, Neff=3.04, m_nu=None, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[0.05 0.1  0.15] eV, Ob0=None)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9d18698d04bfa5d55ddcae0f12ee69266bfed44f4b0fd81018487132da078301", "warmup_time": -1}, "cosmology.LambdaCDMBenchmarks.time_lumdist": {"code": "class LambdaCDMBenchmarks:\n    def time_lumdist(self, cosmo):\n        self.cosmology.luminosity_distance(self.test_zs)\n\n    def setup(self, cosmo):\n        self.cosmology = cosmo\n        self.test_zs = np.linspace(0.1, 5.0, 200)", "min_run_count": 2, "name": "cosmology.LambdaCDMBenchmarks.time_lumdist", "number": 0, "param_names": ["param1"], "params": [["LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=0.0 K, Neff=3.04, m_nu=None, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Ode0=0.65, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=2.7 K, Neff=4.0, m_nu=[0. 0. 0. 0.] eV, Ob0=None)", "LambdaCDM(H0=65.0 km / (Mpc s), Om0=0.4, Ode0=0.2, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=0.0 K, Neff=3.04, m_nu=None, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[0. 0. 0.] eV, Ob0=None)", "FlatLambdaCDM(H0=65.0 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[0.05 0.1  0.15] eV, Ob0=None)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5bac457205366118e159292716591c45c0cfc49c2e2729149b83abfbb3e6ed3e", "warmup_time": -1}, "imports.timeraw_import_astropy": {"code": "def timeraw_import_astropy():\n    return \"\"\"\n    import astropy\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ea26c812c50a70ee882d223711f12e8936cf4c87bd06969bc532787387d61336", "warmup_time": -1}, "imports.timeraw_import_astropy_config": {"code": "def timeraw_import_astropy_config():\n    return \"\"\"\n    from astropy import config\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_config", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6b970d9c0130c5c9cca4fc6db60cb58b3ded95fed717d621d660c1308b00d7d7", "warmup_time": -1}, "imports.timeraw_import_astropy_constants": {"code": "def timeraw_import_astropy_constants():\n    return \"\"\"\n    from astropy import constants\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_constants", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7439b98b809d28139b7fa055553a1a6224e86f864bc497da5bd8769a3b4124c8", "warmup_time": -1}, "imports.timeraw_import_astropy_convolution": {"code": "def timeraw_import_astropy_convolution():\n    return \"\"\"\n    from astropy import convolution\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_convolution", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "da36c30a90738e808255882af5867c908a3812133832b53c767864eb857a9e74", "warmup_time": -1}, "imports.timeraw_import_astropy_coordinates": {"code": "def timeraw_import_astropy_coordinates():\n    return \"\"\"\n    from astropy import coordinates\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_coordinates", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ed01aba793b7fed9316f77dec4b8ff25ae5a96679a2ce80e70dd4d8708b225f8", "warmup_time": -1}, "imports.timeraw_import_astropy_cosmology": {"code": "def timeraw_import_astropy_cosmology():\n    return \"\"\"\n    from astropy import cosmology\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_cosmology", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a5e4a2e0ceb3857ce38d76ce57bb983fd9f392264e0222d7441848fe4b3584c1", "warmup_time": -1}, "imports.timeraw_import_astropy_io": {"code": "def timeraw_import_astropy_io():\n    return \"\"\"\n    from astropy import io\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "95180ac8aa22cdc0fb5a43a96bf20efcb1e1bc560ce0f47a90dffa5a1b28ee31", "warmup_time": -1}, "imports.timeraw_import_astropy_io_ascii": {"code": "def timeraw_import_astropy_io_ascii():\n    return \"\"\"\n    from astropy.io import ascii\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_ascii", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b6c689fe5b6f12df19fdef5bd6501d9590181cb946a1a6b420f732d963a35065", "warmup_time": -1}, "imports.timeraw_import_astropy_io_fits": {"code": "def timeraw_import_astropy_io_fits():\n    return \"\"\"\n    from astropy.io import fits\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_fits", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dc9210f51ba4e364aa881f2696a323f17552ff90858e960fd20cb8dfd201e16f", "warmup_time": -1}, "imports.timeraw_import_astropy_io_misc": {"code": "def timeraw_import_astropy_io_misc():\n    return \"\"\"\n    from astropy.io import misc\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_misc", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a0d0c00c2c66bb073f81462602d6dabe6edcb46cc7059d1a9d40653679f9b732", "warmup_time": -1}, "imports.timeraw_import_astropy_io_misc_asdf": {"code": "def timeraw_import_astropy_io_misc_asdf():\n    return \"\"\"\n    from astropy.io.misc import asdf\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_misc_asdf", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "44c62c277ed3f6ce879f15331614a8b941d4afeb75f07195452c3bb517769c2a", "warmup_time": -1}, "imports.timeraw_import_astropy_io_misc_hdf5": {"code": "def timeraw_import_astropy_io_misc_hdf5():\n    return \"\"\"\n    from astropy.io.misc import hdf5\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_misc_hdf5", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e5115e38f8ef5a5d479bb15db3eac4c30d7000a2f7a7bbe98bab8f3ef17a13f0", "warmup_time": -1}, "imports.timeraw_import_astropy_io_misc_pandas": {"code": "def timeraw_import_astropy_io_misc_pandas():\n    return \"\"\"\n    from astropy.io.misc import pandas\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_misc_pandas", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e75e5fa4455461aeb57fc2bcb203ac2c75e61b208ba30766faeae4531976e9a2", "warmup_time": -1}, "imports.timeraw_import_astropy_io_misc_yaml": {"code": "def timeraw_import_astropy_io_misc_yaml():\n    return \"\"\"\n    from astropy.io.misc import yaml\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_misc_yaml", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a88fc234536e16ebae27eb8badeece08711bc0a7a68d371e799c6c7c140e17b", "warmup_time": -1}, "imports.timeraw_import_astropy_io_votable": {"code": "def timeraw_import_astropy_io_votable():\n    return \"\"\"\n    from astropy.io import votable\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_io_votable", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e15dc768e2e25a7ba27038a4ad0d51ba065a4dc671f4aef9eb72049467d4e2ca", "warmup_time": -1}, "imports.timeraw_import_astropy_logger": {"code": "def timeraw_import_astropy_logger():\n    return \"\"\"\n    from astropy import logger\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_logger", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "56651f5f245ac0880ef4f7ec6dc4827f6b500a5a73ea61bae44ad32e0d4f81bb", "warmup_time": -1}, "imports.timeraw_import_astropy_modeling": {"code": "def timeraw_import_astropy_modeling():\n    return \"\"\"\n    from astropy import modeling\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_modeling", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d0128d1c212ec55e1dc29682e478dd9d774710c3e7b4148dba94e0979ef4a917", "warmup_time": -1}, "imports.timeraw_import_astropy_nddata": {"code": "def timeraw_import_astropy_nddata():\n    return \"\"\"\n    from astropy import nddata\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_nddata", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3638416b7a696dacce4fc0d6c9a35ffa37a9097c6df8e12dac29661796ba884e", "warmup_time": -1}, "imports.timeraw_import_astropy_samp": {"code": "def timeraw_import_astropy_samp():\n    return \"\"\"\n    from astropy import samp\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_samp", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9829901b2814d1ef3d3e84572078f4a963ddd5d2a9b1fd42dff5115dbd99f9df", "warmup_time": -1}, "imports.timeraw_import_astropy_stats": {"code": "def timeraw_import_astropy_stats():\n    return \"\"\"\n    from astropy import stats\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_stats", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "359fe354a4516d5263994fa22ab645486b7d8eb8fb110b821149d412bb763c5b", "warmup_time": -1}, "imports.timeraw_import_astropy_table": {"code": "def timeraw_import_astropy_table():\n    return \"\"\"\n    from astropy import table\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_table", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6afc1cc932fa23faeda462cced541ab9ade0d61b876792c11e53510529b0590d", "warmup_time": -1}, "imports.timeraw_import_astropy_tests": {"code": "def timeraw_import_astropy_tests():\n    return \"\"\"\n    from astropy import tests\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_tests", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "622223e4bc124e518327f13056942de7ad28956b99d5c312d8bbcd3b947ae8af", "warmup_time": -1}, "imports.timeraw_import_astropy_tests_runner": {"code": "def timeraw_import_astropy_tests_runner():\n    return \"\"\"\n    from astropy.tests import runner\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_tests_runner", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4115852ed7cdac07cb229a770dbe2c655ccfc9814e1dd075472715d7efeeb6c3", "warmup_time": -1}, "imports.timeraw_import_astropy_time": {"code": "def timeraw_import_astropy_time():\n    return \"\"\"\n    from astropy import time\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_time", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "813495da5d763c1ebbaaae2d06cd6c254e317a7e07a26b5d8c8a7d407082b333", "warmup_time": -1}, "imports.timeraw_import_astropy_timeseries": {"code": "def timeraw_import_astropy_timeseries():\n    return \"\"\"\n    from astropy import timeseries\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_timeseries", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "af7aed179148d6fcf7163c1e40c02b670db092518265c949b85a89d621754c6a", "warmup_time": -1}, "imports.timeraw_import_astropy_timeseries_io": {"code": "def timeraw_import_astropy_timeseries_io():\n    return \"\"\"\n    from astropy.timeseries import io\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_timeseries_io", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eaae72aea78b860b7cbec58457300bc087e0bfe7a989e20bcfdd01a197902abe", "warmup_time": -1}, "imports.timeraw_import_astropy_timeseries_periodograms": {"code": "def timeraw_import_astropy_timeseries_periodograms():\n    return \"\"\"\n    from astropy.timeseries import periodograms\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_timeseries_periodograms", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e2381104fd12b8ce5769863df5605a037ad00b6e116ffc673d371727571b8636", "warmup_time": -1}, "imports.timeraw_import_astropy_uncertainty": {"code": "def timeraw_import_astropy_uncertainty():\n    return \"\"\"\n    from astropy import uncertainty\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_uncertainty", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dfb05b1a2ffa684be8be961d6d9b3443bca67e008e80217c04ceb0b0183b260c", "warmup_time": -1}, "imports.timeraw_import_astropy_units": {"code": "def timeraw_import_astropy_units():\n    return \"\"\"\n    from astropy import units\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_units", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "329df533a3b0a2ecaa5eec3f7b811bd49e0a03c2c42418ca2ab31470245eb17e", "warmup_time": -1}, "imports.timeraw_import_astropy_units_quantity": {"code": "def timeraw_import_astropy_units_quantity():\n    return \"\"\"\n    from astropy.units import quantity\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_units_quantity", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3cc8eddc6ce081de0bcb00350b1055c5525fb44c4d53b835fea3db6e790c3865", "warmup_time": -1}, "imports.timeraw_import_astropy_utils": {"code": "def timeraw_import_astropy_utils():\n    return \"\"\"\n    from astropy import utils\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_utils", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac19e1133dea8999702c948ec62f77130cce377514ea3f64040e36f78a09c234", "warmup_time": -1}, "imports.timeraw_import_astropy_utils_iers": {"code": "def timeraw_import_astropy_utils_iers():\n    return \"\"\"\n    from astropy.utils import iers\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_utils_iers", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d69a717ed17eff31aa6b5fdf573a5e8274a0898283215e309cb813661d88e9f6", "warmup_time": -1}, "imports.timeraw_import_astropy_visualization": {"code": "def timeraw_import_astropy_visualization():\n    return \"\"\"\n    from astropy import visualization\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_visualization", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca3e1af8ae0fda8097e6a23391a39db918554540c1989a7ebbdfcd93d9230eb7", "warmup_time": -1}, "imports.timeraw_import_astropy_visualization_wcsaxes": {"code": "def timeraw_import_astropy_visualization_wcsaxes():\n    return \"\"\"\n    from astropy.visualization import wcsaxes\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_visualization_wcsaxes", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "28c926a9e55ebbf3af0f6e76cce4062b0808acd1a4af7558776727edf62516c1", "warmup_time": -1}, "imports.timeraw_import_astropy_wcs": {"code": "def timeraw_import_astropy_wcs():\n    return \"\"\"\n    from astropy import wcs\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_wcs", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "73e4e209025138531aa31d8714a18708dbb092dace44429e906329665fd8b5e2", "warmup_time": -1}, "imports.timeraw_import_astropy_wcs_wcsapi": {"code": "def timeraw_import_astropy_wcs_wcsapi():\n    return \"\"\"\n    from astropy.wcs import wcsapi\n    \"\"\"", "min_run_count": 2, "name": "imports.timeraw_import_astropy_wcs_wcsapi", "number": 1, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7f3e1991f60f7295ed17cc49a00a6af9055182e0ae60a673e96d61ec53135c22", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_base_splitter": {"code": "class CoreSuite:\n    def time_base_splitter(self):\n        core.BaseSplitter().process_val(self.line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_base_splitter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ef95250cdacbcad30d437c583c0005f2e0f100ed28e242aea22dfd55507626f2", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_continuation_inputter": {"code": "class CoreSuite:\n    def time_continuation_inputter(self):\n        core.ContinuationLinesInputter().process_lines(self.lines)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_continuation_inputter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "406566039a7c4a88ddbba6da758e5757bc52acdbf7fe159d5324696a33b7f960", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_convert_vals": {"code": "class CoreSuite:\n    def time_convert_vals(self):\n        core.TableOutputter()._convert_vals(self.cols)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_convert_vals", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0c660365b4b3180a53e83e7b346bbb72270cbb17c23a7b9c343b9e62bd6be16d", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_default_splitter_call": {"code": "class CoreSuite:\n    def time_default_splitter_call(self):\n        core.DefaultSplitter()(self.csv_line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_default_splitter_call", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9b11dacb692c8e31688afc0031aa584030b2b4311f16ab0de8e61d1111f68568", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_default_splitter_join": {"code": "class CoreSuite:\n    def time_default_splitter_join(self):\n        core.DefaultSplitter().join(self.vals)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_default_splitter_join", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "306bb839233283dd45a91d2646131b786fecc79198f55c91a843d8d05bbf062a", "warmup_time": -1}, "io_ascii.core.CoreSuite.time_whitespace_splitter": {"code": "class CoreSuite:\n    def time_whitespace_splitter(self):\n        core.WhitespaceSplitter().process_line(self.line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]", "min_run_count": 2, "name": "io_ascii.core.CoreSuite.time_whitespace_splitter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ab9241b763369886db83aff56a4a41a13296bdc6de02fd6cca426503e4195b81", "warmup_time": -1}, "io_ascii.fixedwidth.FixedWidthSuite.time_header": {"code": "class FixedWidthSuite:\n    def time_header(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = ascii.FixedWidthHeader()\n        self.header.start_line = 0\n        self.header.col_starts = None\n        self.header.col_ends = None\n        self.splitter = ascii.FixedWidthSplitter()\n        f = open(os.path.join(HERE, 'files', 'fixed_width', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.header.get_cols(self.lines)\n        self.splitter.cols = self.header.cols\n        self.data = ascii.FixedWidthData()", "min_run_count": 2, "name": "io_ascii.fixedwidth.FixedWidthSuite.time_header", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ab31959770db8530c2a7211c49c8d5a7db6c42b75ff8fb0bac4be7689f1837ea", "warmup_time": -1}, "io_ascii.fixedwidth.FixedWidthSuite.time_splitter": {"code": "class FixedWidthSuite:\n    def time_splitter(self):\n        self.splitter(self.lines[1:])\n\n    def setup(self):\n        self.header = ascii.FixedWidthHeader()\n        self.header.start_line = 0\n        self.header.col_starts = None\n        self.header.col_ends = None\n        self.splitter = ascii.FixedWidthSplitter()\n        f = open(os.path.join(HERE, 'files', 'fixed_width', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.header.get_cols(self.lines)\n        self.splitter.cols = self.header.cols\n        self.data = ascii.FixedWidthData()", "min_run_count": 2, "name": "io_ascii.fixedwidth.FixedWidthSuite.time_splitter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a8f2eed392691b8fede23e560b4b933aef960db35ac1dafac4857c53e839ecf0", "warmup_time": -1}, "io_ascii.ipac.IPACSuite.time_data_str_vals": {"code": "class IPACSuite:\n    def time_data_str_vals(self):\n        self.data.str_vals()\n\n    def setup(self):\n    \n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)\n        self.reader = Ipac()\n        self.header = self.reader.header\n        self.data = self.reader.data\n        self.splitter = self.reader.data.splitter\n        self.header.cols = list(self.table.columns.values())\n        self.data.cols = list(self.table.columns.values())\n        self.data._set_fill_values(self.data.cols)", "min_run_count": 2, "name": "io_ascii.ipac.IPACSuite.time_data_str_vals", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8a3bdce4fcf48e81e8ce41f7a95624fa436aa50ff43ef6742ca6841c5a612078", "warmup_time": -1}, "io_ascii.ipac.IPACSuite.time_get_cols": {"code": "class IPACSuite:\n    def time_get_cols(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n    \n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)\n        self.reader = Ipac()\n        self.header = self.reader.header\n        self.data = self.reader.data\n        self.splitter = self.reader.data.splitter\n        self.header.cols = list(self.table.columns.values())\n        self.data.cols = list(self.table.columns.values())\n        self.data._set_fill_values(self.data.cols)", "min_run_count": 2, "name": "io_ascii.ipac.IPACSuite.time_get_cols", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c905b1e6332762afc6abd89121edc86fc36facdd98ed210664104695bb4b097b", "warmup_time": -1}, "io_ascii.ipac.IPACSuite.time_header_str_vals": {"code": "class IPACSuite:\n    def time_header_str_vals(self):\n        self.header.str_vals()\n\n    def setup(self):\n    \n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)\n        self.reader = Ipac()\n        self.header = self.reader.header\n        self.data = self.reader.data\n        self.splitter = self.reader.data.splitter\n        self.header.cols = list(self.table.columns.values())\n        self.data.cols = list(self.table.columns.values())\n        self.data._set_fill_values(self.data.cols)", "min_run_count": 2, "name": "io_ascii.ipac.IPACSuite.time_header_str_vals", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "439647016a26240060528ce9b7374314566ef65e627fcd04e61558d11ac3fdb7", "warmup_time": -1}, "io_ascii.ipac.IPACSuite.time_splitter": {"code": "class IPACSuite:\n    def time_splitter(self):\n        self.splitter.join(self.vals, self.widths)\n\n    def setup(self):\n    \n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)\n        self.reader = Ipac()\n        self.header = self.reader.header\n        self.data = self.reader.data\n        self.splitter = self.reader.data.splitter\n        self.header.cols = list(self.table.columns.values())\n        self.data.cols = list(self.table.columns.values())\n        self.data._set_fill_values(self.data.cols)", "min_run_count": 2, "name": "io_ascii.ipac.IPACSuite.time_splitter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a1bb23dfe8d83fee56ad9823654a874885f8c656ecbb4ce7c717c33d83183b62", "warmup_time": -1}, "io_ascii.main.AastexFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.AastexFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.AastexInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.AastexInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.AastexString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.AastexString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.AastexString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.BasicFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.BasicFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.BasicInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.BasicInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.BasicString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.BasicString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.BasicString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CommentedHeaderFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CommentedHeaderFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CommentedHeaderInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CommentedHeaderInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CommentedHeaderString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CommentedHeaderString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CommentedHeaderString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CsvFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CsvFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CsvInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CsvInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.CsvString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.CsvString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.CsvString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthNoHeaderString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthNoHeaderString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.FixedWidthTwoLineString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.FixedWidthTwoLineString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.IpacFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.IpacFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.IpacInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.IpacInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.IpacString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.IpacString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.IpacString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.LatexFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.LatexFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.LatexInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.LatexInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.LatexString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.LatexString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.LatexString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.NoHeaderFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.NoHeaderFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.NoHeaderInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.NoHeaderInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.NoHeaderString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.NoHeaderString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.NoHeaderString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.RdbFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.RdbFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.RdbInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.RdbInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.RdbString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.RdbString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.RdbString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.SextractorFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.SextractorFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.SextractorInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.SextractorInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.SextractorString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.SextractorString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.TabFloat.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabFloat.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.TabFloat.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabFloat.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.TabInt.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabInt.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.TabInt.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabInt.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.main.TabString.time_read": {"code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabString.time_read", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20", "warmup_time": -1}, "io_ascii.main.TabString.time_write": {"code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()", "min_run_count": 2, "name": "io_ascii.main.TabString.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754", "warmup_time": -1}, "io_ascii.rdb.RDBSuite.time_get_cols": {"code": "class RDBSuite:\n    def time_get_cols(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = basic.RdbHeader()\n        self.header.splitter.delimiter = '\\t'\n        f = open(os.path.join(HERE,'files','rdb', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()", "min_run_count": 2, "name": "io_ascii.rdb.RDBSuite.time_get_cols", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "37775e9215e57ff1ba0ec99edd94cbc2a293a129a551ed55f92e669007bad661", "warmup_time": -1}, "io_ascii.sextractor.SExtractorSuite.time_header": {"code": "class SExtractorSuite:\n    def time_header(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = sextractor.SExtractorHeader()\n        self.lines = []\n        i = 0\n        while i < 100000:\n            if i % 20 == 0 and i != 0:\n                i += 4\n            i += 1\n            self.lines.append('# {} {} Description [pixel**2]'.format(\n                                                        i, randword()))\n        self.lines.append('Non-header line')", "min_run_count": 2, "name": "io_ascii.sextractor.SExtractorSuite.time_header", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a9db4d189763ff1473f14cb8d568fbe618facb3d376edc5a200bf69eefc7a110", "warmup_time": -1}, "io_ascii.table.TableSuite.mem_table_init": {"code": "class TableSuite:\n    def mem_table_init(self):\n        return table.Table(self.lst).as_array()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "name": "io_ascii.table.TableSuite.mem_table_init", "param_names": [], "params": [], "timeout": 60.0, "type": "memory", "unit": "bytes", "version": "793381304358f87f1bd4b3c8547e0be9868020c921211babe0520d6e8613811a"}, "io_ascii.table.TableSuite.mem_table_outputter": {"code": "class TableSuite:\n    def mem_table_outputter(self):\n        return self.outputter(self.cols, {'table': {}}).as_array()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "name": "io_ascii.table.TableSuite.mem_table_outputter", "param_names": [], "params": [], "timeout": 60.0, "type": "memory", "unit": "bytes", "version": "d928e14704016b4a8ad0820da275fa61e8e9aa35c7f6cb9b63415e3da9bfae0e"}, "io_ascii.table.TableSuite.time_str_vals_float": {"code": "class TableSuite:\n    def time_str_vals_float(self):\n        self.table_cols[1].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "min_run_count": 2, "name": "io_ascii.table.TableSuite.time_str_vals_float", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "07b302e7fc0136b4565c363219c6504885ae486e9aecef91d35043884fccadfe", "warmup_time": -1}, "io_ascii.table.TableSuite.time_str_vals_int": {"code": "class TableSuite:\n    def time_str_vals_int(self):\n        self.table_cols[0].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "min_run_count": 2, "name": "io_ascii.table.TableSuite.time_str_vals_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2ac1d089e02b0b66250a1108b23b09c3b63425645e484322dd071d6bf1d05e08", "warmup_time": -1}, "io_ascii.table.TableSuite.time_str_vals_str": {"code": "class TableSuite:\n    def time_str_vals_str(self):\n        self.table_cols[2].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "min_run_count": 2, "name": "io_ascii.table.TableSuite.time_str_vals_str", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "84848bbd6d006c72fc9be7342626812fd2e50d8a46a77b3c108ece91cc7a9625", "warmup_time": -1}, "io_ascii.table.TableSuite.time_table_init_from_list": {"code": "class TableSuite:\n    def time_table_init_from_list(self):\n        self.table._init_from_list(self.table_cols, ['1', '2', '3'],\n                                   [None, None, None], 3, True)\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "min_run_count": 2, "name": "io_ascii.table.TableSuite.time_table_init_from_list", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5c22449e5e1987a94365b5d46f5f51e7980244904ef3639131140fb94e4a56c1", "warmup_time": -1}, "io_ascii.table.TableSuite.time_table_outputter": {"code": "class TableSuite:\n    def time_table_outputter(self):\n        self.outputter(self.cols, {'table': {}})\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                                  range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()", "min_run_count": 2, "name": "io_ascii.table.TableSuite.time_table_outputter", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5d7c9083b895951c9b0c0f5d82536b9f1547249f17b5775c78ede849a20ea2e9", "warmup_time": -1}, "io_fits.FITSBinTableHDU.time_from_columns_bytes": {"code": "class FITSBinTableHDU:\n    def time_from_columns_bytes(self):\n        x = np.repeat(b'a', 2_000_000)\n        array = np.array(x, dtype=[('col', 'S1')])\n        fits.BinTableHDU.from_columns(array)", "min_run_count": 2, "name": "io_fits.FITSBinTableHDU.time_from_columns_bytes", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "873e9f809455ab1378f9d5ea753e35754337626c1f958069b5d9ff333e42cf1e", "warmup_time": -1}, "io_fits.FITSHDUList.time_getheader": {"code": "class FITSHDUList:\n    def time_getheader(self):\n        fits.getheader(self.filename)\n\n    def setup_cache(self):\n        hdr = make_header()\n        hdul = fits.HDUList([fits.PrimaryHDU(header=hdr)] +\n                            [fits.ImageHDU(header=hdr) for _ in range(30)])\n        hdul.writeto(self.filename)", "min_run_count": 2, "name": "io_fits.FITSHDUList.time_getheader", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "io_fits:98", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e0ac15e42b25d59c770ec7969000be0f2248e1af25005ae242f569177f633540", "warmup_time": -1}, "io_fits.FITSHDUList.time_getheader_ext50": {"code": "class FITSHDUList:\n    def time_getheader_ext50(self):\n        fits.getheader(self.filename, ext=20)\n\n    def setup_cache(self):\n        hdr = make_header()\n        hdul = fits.HDUList([fits.PrimaryHDU(header=hdr)] +\n                            [fits.ImageHDU(header=hdr) for _ in range(30)])\n        hdul.writeto(self.filename)", "min_run_count": 2, "name": "io_fits.FITSHDUList.time_getheader_ext50", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "io_fits:98", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "34caab484072c438c83a6672b071be9f4e098fa93095bd242c3beef0fd4fef4f", "warmup_time": -1}, "io_fits.FITSHDUList.time_len": {"code": "class FITSHDUList:\n    def time_len(self):\n        with fits.open(self.filename) as hdul:\n            len(hdul)\n\n    def setup_cache(self):\n        hdr = make_header()\n        hdul = fits.HDUList([fits.PrimaryHDU(header=hdr)] +\n                            [fits.ImageHDU(header=hdr) for _ in range(30)])\n        hdul.writeto(self.filename)", "min_run_count": 2, "name": "io_fits.FITSHDUList.time_len", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "io_fits:98", "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a9f47d6f62ce16994ce4c88f18538860f86c6218632a1c1a4b79b2b45ee2b953", "warmup_time": -1}, "io_fits.FITSHeader.time_fromstring": {"code": "class FITSHeader:\n    def time_fromstring(self):\n        fits.Header.fromstring(self.hdr_string)\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_fromstring", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3234919da8be45519bcc25b55e86b4bc89cff61c0a0d392ee9580b7b4fe5e423", "warmup_time": -1}, "io_fits.FITSHeader.time_get_float": {"code": "class FITSHeader:\n    def time_get_float(self):\n        self.hdr.get('FLT999')\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_get_float", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "00ab909c46d9216d744cf820f83dd46ddad909a3b5908a1beaf69196f754e429", "warmup_time": -1}, "io_fits.FITSHeader.time_get_hierarch": {"code": "class FITSHeader:\n    def time_get_hierarch(self):\n        self.hdr.get('HIERARCH FOO BAR 999')\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_get_hierarch", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1bde7a3abb0d3d81239c9f9f3b61cb8b91f1e641c59d9daf64bcdd138f3f20e7", "warmup_time": -1}, "io_fits.FITSHeader.time_get_int": {"code": "class FITSHeader:\n    def time_get_int(self):\n        self.hdr.get('INT999')\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_get_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0f838a0e87478d8113791bd9b2c77332784ec2ada47ec50a22d5d255b6aa6625", "warmup_time": -1}, "io_fits.FITSHeader.time_get_str": {"code": "class FITSHeader:\n    def time_get_str(self):\n        self.hdr.get('STR999')\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_get_str", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b2891d9b4b836d96029cecba62ce013d75ab97114584edaa466fb86b8aa1b22e", "warmup_time": -1}, "io_fits.FITSHeader.time_tostring": {"code": "class FITSHeader:\n    def time_tostring(self):\n        self.hdr.tostring()\n\n    def setup(self):\n        self.hdr = make_header()\n        self.hdr_string = self.hdr.tostring()", "min_run_count": 2, "name": "io_fits.FITSHeader.time_tostring", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fc00e8adbf6c0b6afe47b9d61f9448c6161b2d508412b3c05f82d14a27aea1fa", "warmup_time": -1}, "io_fits.FITSHighLevelTableBenchmarks.time_read_nommap": {"code": "class FITSHighLevelTableBenchmarks:\n    def time_read_nommap(self):\n        self.table_bytes.seek(0)\n        try:\n            Table.read(self.table_bytes, format='fits', memmap=False)\n        except TypeError:\n            Table.read(self.table_bytes, format='fits')\n\n    def setup(self):\n    \n        N = 2_000_000\n    \n        self.table_bytes = BytesIO()\n    \n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(self.table_bytes, format='fits')", "min_run_count": 2, "name": "io_fits.FITSHighLevelTableBenchmarks.time_read_nommap", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aad5f871ef8603c05f0a64ae405c585e95d081798cb3576da10a6bd73d17d3bf", "warmup_time": -1}, "io_fits.FITSHighLevelTableBenchmarks.time_write": {"code": "class FITSHighLevelTableBenchmarks:\n    def time_write(self):\n        N = 1_000_000\n        table_bytes = BytesIO()\n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(table_bytes, format='fits')\n\n    def setup(self):\n    \n        N = 2_000_000\n    \n        self.table_bytes = BytesIO()\n    \n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(self.table_bytes, format='fits')", "min_run_count": 2, "name": "io_fits.FITSHighLevelTableBenchmarks.time_write", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dbe7f96c19284a4c494c1f35313cd7f12a367d222c3dffb9c45dab2372722556", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelNoUnits.time_big": {"code": "class EvaluateCompoundModelNoUnits:\n    def time_big(self):\n        r, d = self.model(x_no_units_big, x_no_units_big)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]],\n                                            translation=[0, 0])\n        self.model = (models.Shift(-10.5) & models.Shift(-13.2) | aff |\n                      models.Scale(.01) & models.Scale(.04) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6, -72.05, 180))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelNoUnits.time_big", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7910aa7015149df0a2dde68091f54998177061100e43fc32d89a7871449c7ae3", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelNoUnits.time_medium": {"code": "class EvaluateCompoundModelNoUnits:\n    def time_medium(self):\n        r, d = self.model(x_no_units_medium, x_no_units_medium)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]],\n                                            translation=[0, 0])\n        self.model = (models.Shift(-10.5) & models.Shift(-13.2) | aff |\n                      models.Scale(.01) & models.Scale(.04) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6, -72.05, 180))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelNoUnits.time_medium", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "40c307032c7136668a9ddda782ee13b2df5c0c617ce00b393404817c2d0a7f17", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelNoUnits.time_scalar": {"code": "class EvaluateCompoundModelNoUnits:\n    def time_scalar(self):\n        r, d = self.model(x_no_units_scalar, x_no_units_scalar)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]],\n                                            translation=[0, 0])\n        self.model = (models.Shift(-10.5) & models.Shift(-13.2) | aff |\n                      models.Scale(.01) & models.Scale(.04) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6, -72.05, 180))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelNoUnits.time_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5865ce2892767c224db72612384f7f634a7ff8103577fc57e5d123fc2abb456b", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelNoUnits.time_small": {"code": "class EvaluateCompoundModelNoUnits:\n    def time_small(self):\n        r, d = self.model(x_no_units_small, x_no_units_small)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]],\n                                            translation=[0, 0])\n        self.model = (models.Shift(-10.5) & models.Shift(-13.2) | aff |\n                      models.Scale(.01) & models.Scale(.04) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6, -72.05, 180))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelNoUnits.time_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "309255930235db8eaf1ecfae1930a00f9cac32cb7ec324bb83907e2062ecdbc0", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelWithUnits.time_big": {"code": "class EvaluateCompoundModelWithUnits:\n    def time_big(self):\n        r, d, = self.model(x_no_units_big * u.pix, x_no_units_big * u.pix)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]] * u.arcsec,\n                                            translation=[0, 0] * u.arcsec)\n        aff.input_units_equivalencies = {'x': u.pixel_scale(1 * u.arcsec/u.pix),\n                                         'y': u.pixel_scale(1 * u.arcsec/u.pix)}\n        self.model = (models.Shift(-10.5 * u.pix) & models.Shift(-13.2 * u.pix) |\n                      aff |\n                      models.Scale(.01 * u.arcsec) & models.Scale(.04 * u.deg) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6 * u.deg, -72.05 * u.deg, 180 * u.deg))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelWithUnits.time_big", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "059b94f9863c57fafc43344ffc3265aad655767f6dd945905def603d7e777b00", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelWithUnits.time_medium": {"code": "class EvaluateCompoundModelWithUnits:\n    def time_medium(self):\n        r, d = self.model(x_no_units_medium * u.pix, x_no_units_medium * u.pix)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]] * u.arcsec,\n                                            translation=[0, 0] * u.arcsec)\n        aff.input_units_equivalencies = {'x': u.pixel_scale(1 * u.arcsec/u.pix),\n                                         'y': u.pixel_scale(1 * u.arcsec/u.pix)}\n        self.model = (models.Shift(-10.5 * u.pix) & models.Shift(-13.2 * u.pix) |\n                      aff |\n                      models.Scale(.01 * u.arcsec) & models.Scale(.04 * u.deg) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6 * u.deg, -72.05 * u.deg, 180 * u.deg))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelWithUnits.time_medium", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6816e68192af9eb03284ab4e411de1b4f9ea3b3289376be3effc272ade0dcc07", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelWithUnits.time_scalar": {"code": "class EvaluateCompoundModelWithUnits:\n    def time_scalar(self):\n        r, d = self.model(x_no_units_scalar * u.pix, x_no_units_scalar * u.pix)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]] * u.arcsec,\n                                            translation=[0, 0] * u.arcsec)\n        aff.input_units_equivalencies = {'x': u.pixel_scale(1 * u.arcsec/u.pix),\n                                         'y': u.pixel_scale(1 * u.arcsec/u.pix)}\n        self.model = (models.Shift(-10.5 * u.pix) & models.Shift(-13.2 * u.pix) |\n                      aff |\n                      models.Scale(.01 * u.arcsec) & models.Scale(.04 * u.deg) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6 * u.deg, -72.05 * u.deg, 180 * u.deg))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelWithUnits.time_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "175be523c850767a6955554517b737160aab5af7ce4ef4314e55ee1bbfa479c1", "warmup_time": -1}, "modeling.compound.EvaluateCompoundModelWithUnits.time_small": {"code": "class EvaluateCompoundModelWithUnits:\n    def time_small(self):\n        r, d = self.model(x_no_units_small * u.pix, x_no_units_small * u.pix)\n\n    def setup(self):\n        aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]] * u.arcsec,\n                                            translation=[0, 0] * u.arcsec)\n        aff.input_units_equivalencies = {'x': u.pixel_scale(1 * u.arcsec/u.pix),\n                                         'y': u.pixel_scale(1 * u.arcsec/u.pix)}\n        self.model = (models.Shift(-10.5 * u.pix) & models.Shift(-13.2 * u.pix) |\n                      aff |\n                      models.Scale(.01 * u.arcsec) & models.Scale(.04 * u.deg) |\n                      models.Pix2Sky_TAN() |\n                      models.RotateNative2Celestial(5.6 * u.deg, -72.05 * u.deg, 180 * u.deg))", "min_run_count": 2, "name": "modeling.compound.EvaluateCompoundModelWithUnits.time_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "390fa00a83cf134f0e2732d1ebb8b4bfa923f434780b5459a30b3995cf6c78c8", "warmup_time": -1}, "modeling.compound.time_init_7_no_units": {"code": "def time_init_7_no_units():\n    m = (models.Shift(-10.5) & models.Shift(-13.2) |\n         models.AffineTransformation2D(matrix=[[1, 0], [0, 1]],\n                                       translation=[0, 0]) |\n         models.Scale(.01) & models.Scale(.04) |\n         models.Pix2Sky_TAN() |\n         models.RotateNative2Celestial(5.6, -72.05, 180))", "min_run_count": 2, "name": "modeling.compound.time_init_7_no_units", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4a2d487b68969ae27d31520ae521f05d6d10a2deda289fc4e5bf61883c77bdea", "warmup_time": -1}, "modeling.compound.time_init_7_with_units": {"code": "def time_init_7_with_units():\n    aff = models.AffineTransformation2D(matrix=[[1, 0], [0, 1]]*u.arcsec,\n                                        translation=[0, 0]*u.arcsec)\n    aff.input_units_equivalencies = {'x': u.pixel_scale(1*u.arcsec/u.pix),\n                                     'y': u.pixel_scale(1*u.arcsec/u.pix)}\n    m = (models.Shift(-10.5*u.pix) & models.Shift(-13.2*u.pix) |\n         aff |\n         models.Scale(.01*u.arcsec) & models.Scale(.04*u.arcsec) |\n         models.Pix2Sky_TAN() |\n         models.RotateNative2Celestial(5.6*u.deg, -72.05*u.deg, 180*u.deg))", "min_run_count": 2, "name": "modeling.compound.time_init_7_with_units", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5194af61b5c0a0ba6f991a39016d1cb8da891c7057229cccf12647453c12a52f", "warmup_time": -1}, "modeling.model.time_eval_gaussian_no_units_big": {"code": "def time_eval_gaussian_no_units_big():\n    gauss1d_no_units(x_no_units_big)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_no_units_big", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eea7834b35ebdbf8d6a6be24d5aa1943c653c4108e57a6ceae923a7487b7c863", "warmup_time": -1}, "modeling.model.time_eval_gaussian_no_units_medium": {"code": "def time_eval_gaussian_no_units_medium():\n    gauss1d_no_units(x_no_units_medium)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_no_units_medium", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b00f3b9d88de9c4dbb454e4c3dbba6cb899df7f5e2f7653bd4667e84a5d1e04b", "warmup_time": -1}, "modeling.model.time_eval_gaussian_no_units_scalar": {"code": "def time_eval_gaussian_no_units_scalar():\n    gauss1d_no_units(x_no_units_scalar)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_no_units_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "653ea162dbc19cb18713d9808efa58a2578649c92b88219d87a453a6f61fd160", "warmup_time": -1}, "modeling.model.time_eval_gaussian_no_units_small": {"code": "def time_eval_gaussian_no_units_small():\n    gauss1d_no_units(x_no_units_small)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_no_units_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0fb916a3251138dabe2c8c5c69502708d508f63e38d44556b66af28cde0d392f", "warmup_time": -1}, "modeling.model.time_eval_gaussian_with_units_big": {"code": "def time_eval_gaussian_with_units_big():\n    gauss1d_with_units(x_with_units_big)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_with_units_big", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "98287f42ef23fa9af4ae0926c4e00c26361c5e4fc5ac1a4d6c265f71a3aaa690", "warmup_time": -1}, "modeling.model.time_eval_gaussian_with_units_medium": {"code": "def time_eval_gaussian_with_units_medium():\n    gauss1d_with_units(x_with_units_medium)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_with_units_medium", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "738ab4ddc951739727f5f86421d59fb06c1adbf63625ba97405bb344c0b13d52", "warmup_time": -1}, "modeling.model.time_eval_gaussian_with_units_scalar": {"code": "def time_eval_gaussian_with_units_scalar():\n    gauss1d_with_units(x_with_units_scalar)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_with_units_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "67d547c82e36ecb2493e01fa9103c858a5c4f8594af171283e7059adfa5aec6a", "warmup_time": -1}, "modeling.model.time_eval_gaussian_with_units_small": {"code": "def time_eval_gaussian_with_units_small():\n    gauss1d_with_units(x_with_units_small)", "min_run_count": 2, "name": "modeling.model.time_eval_gaussian_with_units_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4f5d3b9c6646246e2765043aab70cbc989c22f842f584e3f19440f155c09cce0", "warmup_time": -1}, "modeling.model.time_init_gaussian_no_units": {"code": "def time_init_gaussian_no_units():\n    m = models.Gaussian1D(amplitude=10, mean=5, stddev=1.2)", "min_run_count": 2, "name": "modeling.model.time_init_gaussian_no_units", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fb5b1807c0e36c07723044807503ec1302e43b43301e354588442e20acccec08", "warmup_time": -1}, "modeling.model.time_init_gaussian_with_units": {"code": "def time_init_gaussian_with_units():\n    m = models.Gaussian1D(amplitude=10*u.Hz, mean=5*u.m, stddev=1.2*u.cm)", "min_run_count": 2, "name": "modeling.model.time_init_gaussian_with_units", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "597db77b9b34f83f9c1301599cfeb315e09bbe723c08823ccf08846fddf4abde", "warmup_time": -1}, "modeling.model.time_model_init": {"code": "def time_model_init():\n    m = models.Shift(2)", "min_run_count": 2, "name": "modeling.model.time_model_init", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2669025669e382f24d826cb361d24077a1fe96fbafe6e98796183b264852daca", "warmup_time": -1}, "modeling.model.time_model_init_2": {"code": "def time_model_init_2():\n    m = models.Polynomial1D(1, c0=.2, c1=3.4)", "min_run_count": 2, "name": "modeling.model.time_model_init_2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8f72659af23424194565aaab5cd4f4343611040123ea19cf092d0b2dec7e9127", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_1d_array": {"code": "class SigmaClipBenchmarks:\n    def time_1d_array(self):\n        self.sigclip(self.data[0][0])\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_1d_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fc10dcb1e6aaa111da09c12756b194db50d44ba21749f639852c5003c7250f8d", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_2d_array": {"code": "class SigmaClipBenchmarks:\n    def time_2d_array(self):\n        self.sigclip(self.data[0])\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_2d_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "df7e384e9a766e38bbb10a01cf468e213e36f8f4a5ba6a93b1cdadb1fe5f371f", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_2d_array_axis": {"code": "class SigmaClipBenchmarks:\n    def time_2d_array_axis(self):\n        self.sigclip(self.data[0], axis=0)\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_2d_array_axis", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "934258e9d1d54ed0653d2bebdc509652435fe618539825b741f2d7f7792e7155", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array": {"code": "class SigmaClipBenchmarks:\n    def time_3d_array(self):\n        self.sigclip(self.data[:, :1024, :1024])\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d23bebeb3489537d166c6da312564f1ed6e3651112789e056404f0db68f98896", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array_axis": {"code": "class SigmaClipBenchmarks:\n    def time_3d_array_axis(self):\n        self.sigclip(self.data, axis=0)\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array_axis", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4ac8702969468e0e54d31ae0b462d645e1b8af9b5a394d408a5de745bf2721fd", "warmup_time": -1}, "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array_axis2": {"code": "class SigmaClipBenchmarks:\n    def time_3d_array_axis2(self):\n        self.sigclip(self.data, axis=(0, 1))\n\n    def setup(self):\n    \n        # Avoid top-level module import to make sure that the benchmarks are\n        # compatible with versions of astropy that did not have this functionality.\n        from astropy.stats import SigmaClip\n    \n        size = (4, 2048, 2048)\n    \n        with NumpyRNGContext(12345):\n            self.data = np.random.normal(size=size)\n    \n            # add outliers\n            nbad = 100000\n            zbad = np.random.randint(low=0, high=size[0] - 1, size=nbad)\n            ybad = np.random.randint(low=0, high=size[1] - 1, size=nbad)\n            xbad = np.random.randint(low=0, high=size[2] - 1, size=nbad)\n            self.data[zbad, ybad, xbad] = (\n                np.random.choice([-1, 1], size=nbad) *\n                (10 + np.random.rand(nbad)))\n    \n            # The defaults use median as the cenfunc and standard\n            # deviation as the stdfunc.  The default iters is 5.\n            self.sigclip = SigmaClip(sigma=3)", "min_run_count": 2, "name": "stats.sigma_clipping.SigmaClipBenchmarks.time_3d_array_axis2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ae3c0a9acb5075c9b0b2ea1285b46bb6d3e24ffbbe6b052c20ac63db5cdd6b65", "warmup_time": -1}, "table.TimeMaskedColumn.time_masked_column_init": {"code": "class TimeMaskedColumn:\n    def time_masked_column_init(self):\n        MaskedColumn(self.dat)\n\n    def setup(self):\n        self.dat = np.arange(1e7)", "min_run_count": 2, "name": "table.TimeMaskedColumn.time_masked_column_init", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "19a45612e8367fc103c72996f1b4a413c4557962a409519e191bcfe6d125ce47", "warmup_time": -1}, "table.TimeMaskedTable.time_add_column": {"code": "class TimeTable:\n    def time_add_column(self):\n        self.table['e'] = self.extra_column\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_add_column", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b2c0ad0af05e6ff645357e4e21fbb3c31b647579f850c111c9494b69fecab587", "warmup_time": -1}, "table.TimeMaskedTable.time_add_row": {"code": "class TimeTable:\n    def time_add_row(self):\n        self.table.add_row(self.extra_row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_add_row", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c3da92e8384276af12dd0b284b378baea2170c58c83b6d61874804cd715d6a5f", "warmup_time": -1}, "table.TimeMaskedTable.time_aggregate": {"code": "class TimeTable:\n    def time_aggregate(self):\n        # Test aggregate with a function that supports reduceat\n        self.table_grouped.groups.aggregate(np.sum)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_aggregate", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d87a6eadd3a4c94d95d33449d19c6c00474eeb1ada4b13633a28ec4e47eb57f6", "warmup_time": -1}, "table.TimeMaskedTable.time_aggregate_noreduceat": {"code": "class TimeTable:\n    def time_aggregate_noreduceat(self):\n        # Test aggregate with a function that doesn't support reduceat\n        self.table_grouped.groups.aggregate(lambda x: np.sum(x))\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_aggregate_noreduceat", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6607870ad7344f17d4ccea4ca0a86ce464eeccd21fe98d970ff2c699f03c7e17", "warmup_time": -1}, "table.TimeMaskedTable.time_column_get": {"code": "class TimeTable:\n    def time_column_get(self):\n        self.table['c']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f863a90229743a65604d98100febf2400d345032ae27cbd7f0450db596a88956", "warmup_time": -1}, "table.TimeMaskedTable.time_column_make_bool_mask": {"code": "class TimeTable:\n    def time_column_make_bool_mask(self):\n        self.table['a'] > 0.6\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_make_bool_mask", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6dfae7f99d875b90ce8bb45b2232e8c9448734810edacf42fcafd45e522d1ff0", "warmup_time": -1}, "table.TimeMaskedTable.time_column_set": {"code": "class TimeTable:\n    def time_column_set(self):\n        self.table['a'] = 0.\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_set", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3b94497b8947080e3a7ad68c0d27b547fda203e3a82a6f9aef412c5b38553ce2", "warmup_time": -1}, "table.TimeMaskedTable.time_column_set_all": {"code": "class TimeTable:\n    def time_column_set_all(self):\n        self.table['b'][:] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_set_all", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "42a14616589c8ebefc8d09c74be3c4b4081dc5025fc1dc68c45b04046129c898", "warmup_time": -1}, "table.TimeMaskedTable.time_column_set_row_subset": {"code": "class TimeTable:\n    def time_column_set_row_subset(self):\n        self.table['b'][self.bool_mask] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_set_row_subset", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f5286a927031d2e4c72969b4294ad326f835625ffff8cab42d5a0fb0fc66d5fc", "warmup_time": -1}, "table.TimeMaskedTable.time_column_set_row_subset_int": {"code": "class TimeTable:\n    def time_column_set_row_subset_int(self):\n        self.table['b'][self.row_indices] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_set_row_subset_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a46311bfa2b1cc228c79ef31d83d80d7211b6f720c0efc76645408ecb0cc88b", "warmup_time": -1}, "table.TimeMaskedTable.time_column_slice_bool": {"code": "class TimeTable:\n    def time_column_slice_bool(self):\n        col_subset = self.table['a'][self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_slice_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "606fa21ee4fae7dd015b43a97a9d3ba938acd3ba1c2b34262dd6bf6d51f33f54", "warmup_time": -1}, "table.TimeMaskedTable.time_column_slice_int": {"code": "class TimeTable:\n    def time_column_slice_int(self):\n        col_subset = self.table['a'][self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_column_slice_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1d1818da027642ddf329e814913cf0be71476438e4a90444aa085d5f92f6fbe2", "warmup_time": -1}, "table.TimeMaskedTable.time_copy_column": {"code": "class TimeTable:\n    def time_copy_column(self):\n        self.table['a'].copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_copy_column", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f1684c651fd087a764de4d038893b4c9610489a81f8162fa217742e1a0921bff", "warmup_time": -1}, "table.TimeMaskedTable.time_copy_table": {"code": "class TimeTable:\n    def time_copy_table(self):\n        self.table.copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_copy_table", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9dfee0ffd435859c66c9d478df0b81fb8b7497a2a81897f10c557f39f695c328", "warmup_time": -1}, "table.TimeMaskedTable.time_group": {"code": "class TimeTable:\n    def time_group(self):\n        self.table.group_by('d')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_group", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "00833c0817e383400bfaa81fbed6cd67f6bf8e38ab39dad34bf18acb12eb6240", "warmup_time": -1}, "table.TimeMaskedTable.time_hstack": {"code": "class TimeTable:\n    def time_hstack(self):\n        hstack([self.table, self.other_table_2])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_hstack", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0bb53b6f70a1c0e044582584e8e4e16e12b0a6d2de3a8031520e683f725548a0", "warmup_time": -1}, "table.TimeMaskedTable.time_init_from_np_array_copy": {"code": "class TimeTable:\n    def time_init_from_np_array_copy(self):\n        Table(self.np_table, copy=True)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_init_from_np_array_copy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4336289776445bd679565fab2aff50641d5bb4d8e1f21f2c8d37a26af69f59f8", "warmup_time": -1}, "table.TimeMaskedTable.time_init_from_np_array_no_copy": {"code": "class TimeTable:\n    def time_init_from_np_array_no_copy(self):\n        Table(self.np_table, copy=False)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_init_from_np_array_no_copy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b13e3a0b7c95d73514fa4353bd5e2fc362b0a2133200cfbca7578616000b7c88", "warmup_time": -1}, "table.TimeMaskedTable.time_item_get_colfirst": {"code": "class TimeTable:\n    def time_item_get_colfirst(self):\n        self.table['b'][300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_item_get_colfirst", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0dd32efbfedd563aa310767ea5c4ed044e744ee7a4fbbd06b2d67f39b0646c2a", "warmup_time": -1}, "table.TimeMaskedTable.time_item_get_rowfirst": {"code": "class TimeTable:\n    def time_item_get_rowfirst(self):\n        self.table[300]['b']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_item_get_rowfirst", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "09093997db41771a090f840eefd60e7d2577c519a976b9b88d799aa21d242a1b", "warmup_time": -1}, "table.TimeMaskedTable.time_iter_row": {"code": "class TimeTable:\n    def time_iter_row(self):\n        for row in self.table:\n            pass\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_iter_row", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5c031f2eb8938c243423fa5dabd4c66ced4063a63b583bd3f54270bc1f211fae", "warmup_time": -1}, "table.TimeMaskedTable.time_join_inner": {"code": "class TimeTable:\n    def time_join_inner(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='inner')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_join_inner", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0c28429345963649f5df731dce5bbd22588b0f465f5112c20ac6e8fc367697c7", "warmup_time": -1}, "table.TimeMaskedTable.time_join_outer": {"code": "class TimeTable:\n    def time_join_outer(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='outer')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_join_outer", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4c3bf2e6aaf0b0fa9873b63128ace026c611e846f2b72ceb1c4a7170dd790984", "warmup_time": -1}, "table.TimeMaskedTable.time_mask_column": {"code": "class TimeMaskedTable:\n    def time_mask_column(self):\n        self.table['a'].mask = self.bool_mask\n\nclass TimeTable:\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_mask_column", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8199306b947c7320fcf35aa5e9c87146b8bb91f9cba9d25fb9290a8ff006cee7", "warmup_time": -1}, "table.TimeMaskedTable.time_multi_column_get": {"code": "class TimeTable:\n    def time_multi_column_get(self):\n        self.table[('a','c')]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_multi_column_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f078ef4c7d77390944802d30e7ef0381d6372c9dd211c3bb6163265eb8a8a0d9", "warmup_time": -1}, "table.TimeMaskedTable.time_read_rows": {"code": "class TimeTable:\n    def time_read_rows(self):\n        for row in self.table:\n            tuple(row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_read_rows", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b8c9879da2aac0e2ec1225c2f64e3b30c8ca22ad100b1eea118285204166f604", "warmup_time": -1}, "table.TimeMaskedTable.time_remove_column": {"code": "class TimeTable:\n    def time_remove_column(self):\n        self.table.remove_column('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_remove_column", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac775b1968a61183af601e5a5ebd1443c52d1e28bdb86520ac2fef19d4c38088", "warmup_time": -1}, "table.TimeMaskedTable.time_remove_row": {"code": "class TimeTable:\n    def time_remove_row(self):\n        self.table.remove_row(6)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_remove_row", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a649c857c45262e8ad834755d02de13041d4fc893ecc1a30d7297f4c36541290", "warmup_time": -1}, "table.TimeMaskedTable.time_remove_rows": {"code": "class TimeTable:\n    def time_remove_rows(self):\n        self.table.remove_rows(self.row_indices)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_remove_rows", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1b7c4ed8b6c2a92d93e9b2ce007c596b7c79317f1427056e26f65f9873a510ef", "warmup_time": -1}, "table.TimeMaskedTable.time_row_get": {"code": "class TimeTable:\n    def time_row_get(self):\n        self.table[300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_row_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "045657db9d7ef5938a36c9885c2627d0a0a8806f51a24693858d11245a8641b0", "warmup_time": -1}, "table.TimeMaskedTable.time_sort": {"code": "class TimeTable:\n    def time_sort(self):\n        self.table.sort('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_sort", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5563d6c2ba316f51667e1e02e88372d03a0d46ce635fcf28c99a19b8a47f364", "warmup_time": -1}, "table.TimeMaskedTable.time_table_slice_bool": {"code": "class TimeTable:\n    def time_table_slice_bool(self):\n        table_subset = self.table[self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_table_slice_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aa3e39b38985bb5ece815375cfeeac330868d465afe58025e987d4e6ee7b6f16", "warmup_time": -1}, "table.TimeMaskedTable.time_table_slice_int": {"code": "class TimeTable:\n    def time_table_slice_int(self):\n        table_subset = self.table[self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_table_slice_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d371f5b0e33a94248be0e224cef150f53d07c64f2e16111a308b57b90ad93080", "warmup_time": -1}, "table.TimeMaskedTable.time_vstack": {"code": "class TimeTable:\n    def time_vstack(self):\n        vstack([self.table, self.table])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeMaskedTable.time_vstack", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "398d840ff2c40a226540b887b02f1c56020693a589a7526505fd59479cc7256b", "warmup_time": -1}, "table.TimeTable.time_add_column": {"code": "class TimeTable:\n    def time_add_column(self):\n        self.table['e'] = self.extra_column\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_add_column", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b2c0ad0af05e6ff645357e4e21fbb3c31b647579f850c111c9494b69fecab587", "warmup_time": -1}, "table.TimeTable.time_add_row": {"code": "class TimeTable:\n    def time_add_row(self):\n        self.table.add_row(self.extra_row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_add_row", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c3da92e8384276af12dd0b284b378baea2170c58c83b6d61874804cd715d6a5f", "warmup_time": -1}, "table.TimeTable.time_aggregate": {"code": "class TimeTable:\n    def time_aggregate(self):\n        # Test aggregate with a function that supports reduceat\n        self.table_grouped.groups.aggregate(np.sum)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_aggregate", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d87a6eadd3a4c94d95d33449d19c6c00474eeb1ada4b13633a28ec4e47eb57f6", "warmup_time": -1}, "table.TimeTable.time_aggregate_noreduceat": {"code": "class TimeTable:\n    def time_aggregate_noreduceat(self):\n        # Test aggregate with a function that doesn't support reduceat\n        self.table_grouped.groups.aggregate(lambda x: np.sum(x))\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_aggregate_noreduceat", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6607870ad7344f17d4ccea4ca0a86ce464eeccd21fe98d970ff2c699f03c7e17", "warmup_time": -1}, "table.TimeTable.time_column_get": {"code": "class TimeTable:\n    def time_column_get(self):\n        self.table['c']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f863a90229743a65604d98100febf2400d345032ae27cbd7f0450db596a88956", "warmup_time": -1}, "table.TimeTable.time_column_make_bool_mask": {"code": "class TimeTable:\n    def time_column_make_bool_mask(self):\n        self.table['a'] > 0.6\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_make_bool_mask", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6dfae7f99d875b90ce8bb45b2232e8c9448734810edacf42fcafd45e522d1ff0", "warmup_time": -1}, "table.TimeTable.time_column_set": {"code": "class TimeTable:\n    def time_column_set(self):\n        self.table['a'] = 0.\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_set", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3b94497b8947080e3a7ad68c0d27b547fda203e3a82a6f9aef412c5b38553ce2", "warmup_time": -1}, "table.TimeTable.time_column_set_all": {"code": "class TimeTable:\n    def time_column_set_all(self):\n        self.table['b'][:] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_set_all", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "42a14616589c8ebefc8d09c74be3c4b4081dc5025fc1dc68c45b04046129c898", "warmup_time": -1}, "table.TimeTable.time_column_set_row_subset": {"code": "class TimeTable:\n    def time_column_set_row_subset(self):\n        self.table['b'][self.bool_mask] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_set_row_subset", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f5286a927031d2e4c72969b4294ad326f835625ffff8cab42d5a0fb0fc66d5fc", "warmup_time": -1}, "table.TimeTable.time_column_set_row_subset_int": {"code": "class TimeTable:\n    def time_column_set_row_subset_int(self):\n        self.table['b'][self.row_indices] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_set_row_subset_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a46311bfa2b1cc228c79ef31d83d80d7211b6f720c0efc76645408ecb0cc88b", "warmup_time": -1}, "table.TimeTable.time_column_slice_bool": {"code": "class TimeTable:\n    def time_column_slice_bool(self):\n        col_subset = self.table['a'][self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_slice_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "606fa21ee4fae7dd015b43a97a9d3ba938acd3ba1c2b34262dd6bf6d51f33f54", "warmup_time": -1}, "table.TimeTable.time_column_slice_int": {"code": "class TimeTable:\n    def time_column_slice_int(self):\n        col_subset = self.table['a'][self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_column_slice_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1d1818da027642ddf329e814913cf0be71476438e4a90444aa085d5f92f6fbe2", "warmup_time": -1}, "table.TimeTable.time_copy_column": {"code": "class TimeTable:\n    def time_copy_column(self):\n        self.table['a'].copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_copy_column", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f1684c651fd087a764de4d038893b4c9610489a81f8162fa217742e1a0921bff", "warmup_time": -1}, "table.TimeTable.time_copy_table": {"code": "class TimeTable:\n    def time_copy_table(self):\n        self.table.copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_copy_table", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9dfee0ffd435859c66c9d478df0b81fb8b7497a2a81897f10c557f39f695c328", "warmup_time": -1}, "table.TimeTable.time_group": {"code": "class TimeTable:\n    def time_group(self):\n        self.table.group_by('d')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_group", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "00833c0817e383400bfaa81fbed6cd67f6bf8e38ab39dad34bf18acb12eb6240", "warmup_time": -1}, "table.TimeTable.time_hstack": {"code": "class TimeTable:\n    def time_hstack(self):\n        hstack([self.table, self.other_table_2])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_hstack", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0bb53b6f70a1c0e044582584e8e4e16e12b0a6d2de3a8031520e683f725548a0", "warmup_time": -1}, "table.TimeTable.time_init_from_np_array_copy": {"code": "class TimeTable:\n    def time_init_from_np_array_copy(self):\n        Table(self.np_table, copy=True)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_init_from_np_array_copy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4336289776445bd679565fab2aff50641d5bb4d8e1f21f2c8d37a26af69f59f8", "warmup_time": -1}, "table.TimeTable.time_init_from_np_array_no_copy": {"code": "class TimeTable:\n    def time_init_from_np_array_no_copy(self):\n        Table(self.np_table, copy=False)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_init_from_np_array_no_copy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b13e3a0b7c95d73514fa4353bd5e2fc362b0a2133200cfbca7578616000b7c88", "warmup_time": -1}, "table.TimeTable.time_item_get_colfirst": {"code": "class TimeTable:\n    def time_item_get_colfirst(self):\n        self.table['b'][300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_item_get_colfirst", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0dd32efbfedd563aa310767ea5c4ed044e744ee7a4fbbd06b2d67f39b0646c2a", "warmup_time": -1}, "table.TimeTable.time_item_get_rowfirst": {"code": "class TimeTable:\n    def time_item_get_rowfirst(self):\n        self.table[300]['b']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_item_get_rowfirst", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "09093997db41771a090f840eefd60e7d2577c519a976b9b88d799aa21d242a1b", "warmup_time": -1}, "table.TimeTable.time_iter_row": {"code": "class TimeTable:\n    def time_iter_row(self):\n        for row in self.table:\n            pass\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_iter_row", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5c031f2eb8938c243423fa5dabd4c66ced4063a63b583bd3f54270bc1f211fae", "warmup_time": -1}, "table.TimeTable.time_join_inner": {"code": "class TimeTable:\n    def time_join_inner(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='inner')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_join_inner", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0c28429345963649f5df731dce5bbd22588b0f465f5112c20ac6e8fc367697c7", "warmup_time": -1}, "table.TimeTable.time_join_outer": {"code": "class TimeTable:\n    def time_join_outer(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='outer')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_join_outer", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4c3bf2e6aaf0b0fa9873b63128ace026c611e846f2b72ceb1c4a7170dd790984", "warmup_time": -1}, "table.TimeTable.time_multi_column_get": {"code": "class TimeTable:\n    def time_multi_column_get(self):\n        self.table[('a','c')]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_multi_column_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f078ef4c7d77390944802d30e7ef0381d6372c9dd211c3bb6163265eb8a8a0d9", "warmup_time": -1}, "table.TimeTable.time_read_rows": {"code": "class TimeTable:\n    def time_read_rows(self):\n        for row in self.table:\n            tuple(row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_read_rows", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b8c9879da2aac0e2ec1225c2f64e3b30c8ca22ad100b1eea118285204166f604", "warmup_time": -1}, "table.TimeTable.time_remove_column": {"code": "class TimeTable:\n    def time_remove_column(self):\n        self.table.remove_column('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_remove_column", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac775b1968a61183af601e5a5ebd1443c52d1e28bdb86520ac2fef19d4c38088", "warmup_time": -1}, "table.TimeTable.time_remove_row": {"code": "class TimeTable:\n    def time_remove_row(self):\n        self.table.remove_row(6)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_remove_row", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a649c857c45262e8ad834755d02de13041d4fc893ecc1a30d7297f4c36541290", "warmup_time": -1}, "table.TimeTable.time_remove_rows": {"code": "class TimeTable:\n    def time_remove_rows(self):\n        self.table.remove_rows(self.row_indices)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_remove_rows", "number": 1, "param_names": [], "params": [], "repeat": 1, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1b7c4ed8b6c2a92d93e9b2ce007c596b7c79317f1427056e26f65f9873a510ef", "warmup_time": -1}, "table.TimeTable.time_row_get": {"code": "class TimeTable:\n    def time_row_get(self):\n        self.table[300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_row_get", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "045657db9d7ef5938a36c9885c2627d0a0a8806f51a24693858d11245a8641b0", "warmup_time": -1}, "table.TimeTable.time_sort": {"code": "class TimeTable:\n    def time_sort(self):\n        self.table.sort('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_sort", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5563d6c2ba316f51667e1e02e88372d03a0d46ce635fcf28c99a19b8a47f364", "warmup_time": -1}, "table.TimeTable.time_table_slice_bool": {"code": "class TimeTable:\n    def time_table_slice_bool(self):\n        table_subset = self.table[self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_table_slice_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aa3e39b38985bb5ece815375cfeeac330868d465afe58025e987d4e6ee7b6f16", "warmup_time": -1}, "table.TimeTable.time_table_slice_int": {"code": "class TimeTable:\n    def time_table_slice_int(self):\n        table_subset = self.table[self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_table_slice_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d371f5b0e33a94248be0e224cef150f53d07c64f2e16111a308b57b90ad93080", "warmup_time": -1}, "table.TimeTable.time_vstack": {"code": "class TimeTable:\n    def time_vstack(self):\n        vstack([self.table, self.table])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6", "min_run_count": 2, "name": "table.TimeTable.time_vstack", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "398d840ff2c40a226540b887b02f1c56020693a589a7526505fd59479cc7256b", "warmup_time": -1}, "table.TimeTableInitWithLists.time_init_lists": {"code": "class TimeTableInitWithLists:\n    def time_init_lists(self):\n        Table([self.dat, self.dat, self.dat], names=['time', 'rate', 'error'])\n\n    def setup(self):\n        self.dat = list(range(100_000))", "min_run_count": 2, "name": "table.TimeTableInitWithLists.time_init_lists", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c9aa93476f939488ac81afca4caf200924a4273a0e4bc081e03d549a6f859b54", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_float_1d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_float_1d(self):\n        Table([self.data_float_1d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_float_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "853e51fe06ac664d8378fe73e2cf469ef8425f98a6f7909afbc438756e30a202", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_int_1d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_int_1d(self):\n        Table([self.data_int_1d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_int_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d34f928b7efcbe26b30180d75ce209184abd9ed4308b172d601ffa22cdce823f", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_int_3d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_int_3d(self):\n        Table([self.data_int_3d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_int_3d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "627199473265c7af875bb5adb277c4a970c71836d84b0453c50fd928e2af5df8", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_int_masked_1d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_int_masked_1d(self):\n        Table([self.data_int_masked_1d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_int_masked_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "14209b3b7e87fbfe73b8d2ed447e22201eaccb04deb2ae4beceab1cdabc0a3ac", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_int_masked_3d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_int_masked_3d(self):\n        Table([self.data_int_masked_3d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_int_masked_3d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "000c911d6f2375b395edcad3bc009581d26c6996832e24ad17ce1b0957fc951a", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_str_1d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_str_1d(self):\n        Table([self.data_str_1d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_str_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3d6e08d939e4c2fd966e518d1faa7bdca0ee512cfd439fad757a27070a3934ca", "warmup_time": -1}, "table.TimeTableInitWithMultiDimLists.time_init_str_masked_1d": {"code": "class TimeTableInitWithMultiDimLists:\n    def time_init_str_masked_1d(self):\n        Table([self.data_str_masked_1d])\n\n    def setup(self):\n        np_data_int = np.arange(1_000_000, dtype=np.int64)\n        np_data_float = np_data_int.astype(np.float64)\n        np_data_str = np_data_int.astype('U')\n    \n        self.data_int_1d = np_data_int.tolist()\n    \n        self.data_int_3d = np_data_int.reshape(1000, 100, 10).tolist()\n    \n        self.data_int_masked_1d = self.data_int_1d.copy()\n        self.data_int_masked_1d[-1] = np.ma.masked\n    \n        self.data_int_masked_3d = self.data_int_3d.copy()\n        self.data_int_masked_3d[-1][-1][-1] = np.ma.masked\n    \n        self.data_float_1d = np_data_float.tolist()\n    \n        self.data_str_1d = np_data_str.tolist()\n    \n        self.data_str_masked_1d = self.data_str_1d.copy()\n        self.data_str_masked_1d[-1] = np.ma.masked", "min_run_count": 2, "name": "table.TimeTableInitWithMultiDimLists.time_init_str_masked_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "974b251043a8e5350e87ee3e45fa77f6108fe133b64d5dc1e418d92cd6a7a0b2", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_np_sqrt": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_sqrt(self):\n        np.sqrt(self.data)\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_np_sqrt", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c41732e115ce8d95bc8640658a9ec5a59cdff75bdc4b310e4c8b5fb485d4f508", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_np_sqrt_out": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_sqrt_out(self):\n        np.sqrt(self.data, out=self.out_sqrt)\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_np_sqrt_out", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "45ddcb23fdc69e40313ee46d9431e2c2d80d50d72f1e022e805c8a43b8c2e93e", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_np_square": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_square(self):\n        np.power(self.data, 2)\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_np_square", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0ecd3562188d5f39332ab7e6c693aa4c5bf076ba49f9cafa1ceb2f694639e219", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_np_square_out": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_square_out(self):\n        np.power(self.data, 2, out=self.out_sq)\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_np_square_out", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3bea77593e2c5d3ae2ab8a991f871063f28e4d1bb24ad90b57b630a4b3176595", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_sqrt": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_sqrt(self):\n        self.data ** 0.5\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_sqrt", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ee1020542a4f32ad52b0d2feaa61ffa79114f5d416cc1d6e563b5c5e2dae20d0", "warmup_time": -1}, "units.TimeQuantityOpLargeArray.time_quantity_square": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_square(self):\n        self.data ** 2\n\nclass TimeQuantityOpLargeArray:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArray.time_quantity_square", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "25ae13030ec849dd21e32cce5e84bcdbc869ee1814599278833492fed3a05c4e", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_add(self):\n        # Same as operator.add\n        self.data + self.data2\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c385cebfe41635e363e477dcb78af200f30065955a278796767c4a451caae1c9", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_equal(self):\n        # Same as operator.eq\n        self.data == self.data2\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b9eb2d23ce1438d33e7a6c9427268e1510d0326bd38ecad2c556256a974781cc", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_mul(self):\n        # Same as operator.mul\n        self.data * self.data2\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_mul", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7751a2973c3e178742fab8fb48b2d37deeb9f1d30f9fa42709bfe7a121fba06d", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_add(self):\n        np.add(self.data, self.data2)\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7de933e8733313f06bdc7db668d354ee1049132e444ed2e2318f44ada5ff32b5", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_equal(self):\n        np.equal(self.data, self.data2)\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "248558ce92d50fa897e52b0331a11dbbb8a59515efd6cef4bff676ed001169f0", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_multiply(self):\n        np.multiply(self.data, self.data2)\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_multiply", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "69dbd5da2de39350eace04fe175f776f41d79f31f652962ceb3508da490ba500", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_subtract(self):\n        np.subtract(self.data, self.data2)\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_subtract", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d63b43847ef0711c37d11de7f00a27d703c6c2199356465aa7748260f4ce7e03", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_truediv(self):\n        np.true_divide(self.data, self.data2)\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_np_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "419f603b0bb9da0db98d7847cfc33e64009f7ffe8affb88d9fe22a3101efb9e0", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_sub(self):\n        # Same as operator.sub\n        self.data - self.data2\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_sub", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2291156c51760e7bfde8a80525db9c92a1569795e75854b72cfe9da8cf9a8540", "warmup_time": -1}, "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_truediv(self):\n        # Since benchmark is PY3 only, this is always true divide.\n        # Same as operator.truediv\n        self.data / self.data2\n\nclass TimeQuantityOpLargeArrayDiffUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArrayDiffUnit.time_quantity_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b97569c5e7e9ea3949d6a792e5a072098dd90e8bafe901e310c975220144754c", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_add(self):\n        # Same as operator.add\n        self.data + self.data2\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1340fecc25ccfe6db8ba2d16b907cdecc04639a5eb0f453948f42583aa2d1020", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_equal(self):\n        # Same as operator.eq\n        self.data == self.data2\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "64fc765c126a1ea33be0fe1bb49cc0d5684cd0504a6ea698db4c0a289f96aa6d", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_mul(self):\n        # Same as operator.mul\n        self.data * self.data2\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_mul", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "902a17a4038cf248441bd8aa9d4d8e17f063cb35ca8daef05bb2fb5599bd63a9", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_add(self):\n        np.add(self.data, self.data2)\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "654dee8983d688239420d427ddc1657b002ccbf3bf7faf2fe803a024244e44fb", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_equal(self):\n        np.equal(self.data, self.data2)\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ea9059e90756adf2c76d445733343ec9700bb5c2a36b6d0d3500881618525ee0", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_multiply(self):\n        np.multiply(self.data, self.data2)\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_multiply", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "709731432d1b10fb1278092a086b905109373969c618296298c0758436bf2799", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_subtract(self):\n        np.subtract(self.data, self.data2)\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_subtract", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d457e6547ebaf3987a3c4a2573c095cd7fa45dad108fced3facac3678425c28c", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_truediv(self):\n        np.true_divide(self.data, self.data2)\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_np_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e5389c843adadc1c3898b7f5a3623ee6b16ac3eabbf7e36e26ad332af83ad19c", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_sub": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_sub(self):\n        # Same as operator.sub\n        self.data - self.data2\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_sub", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f633c739ee865adca9fead5896feec7037bcd079ec31c14132cd331f5475b56f", "warmup_time": -1}, "units.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_truediv(self):\n        # Since benchmark is PY3 only, this is always true divide.\n        # Same as operator.truediv\n        self.data / self.data2\n\nclass TimeQuantityOpLargeArraySameUnit:\n    def setup(self):\n        data = np.arange(1e6) + 1\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpLargeArraySameUnit.time_quantity_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "87e7418488429f293a0fe0b0dadb7acf20a52dd3591ad92e9dfcdeeb4e908374", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_np_sqrt": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_sqrt(self):\n        np.sqrt(self.data)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_np_sqrt", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7caa190246a1218ee3d78f473e05d78c94503250a5c420ddc5e0af6a3b1b899a", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_np_sqrt_out": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_sqrt_out(self):\n        np.sqrt(self.data, out=self.out_sqrt)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_np_sqrt_out", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "38132f65bc847f1086415b61226d21dd1286e302705268c7531aee3cb40e027f", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_np_square": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_square(self):\n        np.power(self.data, 2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_np_square", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "722d26938323aebc790084f1a9e380be04a7df4a5d7f73e2c0e51911f0556698", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_np_square_out": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_np_square_out(self):\n        np.power(self.data, 2, out=self.out_sq)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_np_square_out", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "64f9162766df7547990a06ced779afb10584cf1ad8e035b024dcf5645b636c2c", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_sqrt": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_sqrt(self):\n        self.data ** 0.5\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_sqrt", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2c0e1c2412f12c10e69e4309c58dc8dce33788ab5b07ea1e8066c23c3727661b", "warmup_time": -1}, "units.TimeQuantityOpSmallArray.time_quantity_square": {"code": "class TimeQuantityOpSmallArray:\n    def time_quantity_square(self):\n        self.data ** 2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.out_sq = data * u.g ** 2\n        self.out_sqrt = data * u.g ** 0.5", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArray.time_quantity_square", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "12d3f19a145231371768969fa5f8278a0147ba7f467211dc1d28e4e70e727c91", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_add(self):\n        # Same as operator.add\n        self.data + self.data2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0d81504f4f1b242de1f59e2ab063da3e645daaf2416a29a3543ae1d67b0c16f1", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_equal(self):\n        # Same as operator.eq\n        self.data == self.data2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0bd368751da8a7cf699cc3b5506d6a1a9a916728fe2d60dc00d0c8f38362314f", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_mul": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_mul(self):\n        # Same as operator.mul\n        self.data * self.data2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_mul", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0fdebeba31662edc0a7953ad173a86749daf325bf79cc4d96db3dda45531001b", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_add(self):\n        np.add(self.data, self.data2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "10bc2cc18d02ec2db40df7a5e95743cf5d8ab46da4ce7070b8f447980c8fc389", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_equal(self):\n        np.equal(self.data, self.data2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "35de01ee895de6e288d8be9f9a8129bcf3a3c807aca16819286cbc7c58b7464e", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_multiply": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_multiply(self):\n        np.multiply(self.data, self.data2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_multiply", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "68ce50141b0faf216b28687045e3b5b1f3e90c8d30f3a701c5fb1b3d5f4423c1", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_subtract": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_subtract(self):\n        np.subtract(self.data, self.data2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_subtract", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5976eb02a4c22931cfe8a53e0662ea551e9d8bcad8dc3ae559ddc92ea08fff6a", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_truediv(self):\n        np.true_divide(self.data, self.data2)\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_np_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac6ce9ff628a808cb007223a9d72d57b84581b016533279483cbd2f27af6f67a", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_sub": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_sub(self):\n        # Same as operator.sub\n        self.data - self.data2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_sub", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7addf2162752672919abc9e95803a571972a1d0de313e65e92cbe979d2be8069", "warmup_time": -1}, "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_truediv(self):\n        # Since benchmark is PY3 only, this is always true divide.\n        # Same as operator.truediv\n        self.data / self.data2\n\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n    \n        # A different but dimensionally compatible unit\n        self.data2 = 0.001 * data * u.kg", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArrayDiffUnit.time_quantity_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "675ddc8c55b1273b5210b8127dea06c9ee5d42c4a3292b5e00d85cc89b7740e7", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_add(self):\n        # Same as operator.add\n        self.data + self.data2\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "db5eac4d553d53a2c73a2a5b0c9664f7aa328de33759deab21ebc45ea384559c", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_equal(self):\n        # Same as operator.eq\n        self.data == self.data2\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3653421d580026ffa717b37ad30bf711b120a1e147621157f8fa94c0ce1b6fd1", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_mul": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_mul(self):\n        # Same as operator.mul\n        self.data * self.data2\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_mul", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c0d41b641af56a1e819ea80933ee0b7492e484c0051492cb767aca7a656682f4", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_add": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_add(self):\n        np.add(self.data, self.data2)\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9e21e621002197a56ec29cbef1528fe5612737320a8a72c6b51b330916e08d16", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_equal": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_equal(self):\n        np.equal(self.data, self.data2)\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_equal", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e14f490308a0eabaf254e1ca5fe97908999dd7ed77a379d7d07cb2bd98d239a4", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_multiply": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_multiply(self):\n        np.multiply(self.data, self.data2)\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_multiply", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7685f6b49aec13a41bbca6518c60d29f3f7db3249c88e00ad42d0c068a9c5a32", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_subtract": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_subtract(self):\n        np.subtract(self.data, self.data2)\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_subtract", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6273a7aacc091f814d9e9fc5e3a43ea94842f71e136211e32930027169486dec", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_np_truediv(self):\n        np.true_divide(self.data, self.data2)\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_np_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b8c3047cf2e12e2cd376a25a8c4870bc9e189c56bdd1c732f3c59566d1c3f778", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_sub": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_sub(self):\n        # Same as operator.sub\n        self.data - self.data2\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_sub", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "79b8850bedab52cc9feab4702429e899eb950d47c2c72f1e397f869f03bed5d0", "warmup_time": -1}, "units.TimeQuantityOpSmallArraySameUnit.time_quantity_truediv": {"code": "class TimeQuantityOpSmallArrayDiffUnit:\n    def time_quantity_truediv(self):\n        # Since benchmark is PY3 only, this is always true divide.\n        # Same as operator.truediv\n        self.data / self.data2\n\nclass TimeQuantityOpSmallArraySameUnit:\n    def setup(self):\n        data = np.array([1., 2., 3.])\n        self.data = data * u.g\n        self.data2 = self.data.copy()", "min_run_count": 2, "name": "units.TimeQuantityOpSmallArraySameUnit.time_quantity_truediv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "90ce3d4ad893becbe16681c6534a2c345f647363c0440f12a8666eea7bff3023", "warmup_time": -1}, "units.mem_unit": {"code": "def mem_unit():\n    return u.erg", "name": "units.mem_unit", "param_names": [], "params": [], "timeout": 60.0, "type": "memory", "unit": "bytes", "version": "3a897822d63f1fc4ebc8b6f605d236642698676d05ca2a2f415a55cee964d2b8"}, "units.time_compose_complex": {"code": "def time_compose_complex():\n    # Composing a complex unit can be very inefficient\n    (u.kg / u.s ** 3 * u.au ** 2.5 / u.yr ** 0.5 / u.sr ** 2).compose()", "min_run_count": 2, "name": "units.time_compose_complex", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "52ea1360a73607e97f50ceef1e3f3e3e848ad83b0b5362a19e4aa3fb3dceca04", "warmup_time": -1}, "units.time_compose_to_bases": {"code": "def time_compose_to_bases():\n    x = copy.copy(u.Ry)\n    x.cgs", "min_run_count": 2, "name": "units.time_compose_to_bases", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "efa81d39b97d426d435dbe325a091874c13cd833db4885fd5e9e1ec35b231e35", "warmup_time": -1}, "units.time_quantity_array_conversion": {"code": "def time_quantity_array_conversion():\n    (a * u.m / u.s).to(u.km / u.hour)", "min_run_count": 2, "name": "units.time_quantity_array_conversion", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "453720a338fd6209fec908aeca1d32fd167c1889d2cf194fb9cc93798ba4f918", "warmup_time": -1}, "units.time_quantity_creation": {"code": "def time_quantity_creation():\n    u.Quantity(a, u.m)", "min_run_count": 2, "name": "units.time_quantity_creation", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "57da636a893f32b10c058bef66b505734774f0254e5ec31d8102670ea3749ba1", "warmup_time": -1}, "units.time_quantity_creation_nocopy": {"code": "def time_quantity_creation_nocopy():\n    u.Quantity(a, u.m, copy=False)", "min_run_count": 2, "name": "units.time_quantity_creation_nocopy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1b32a659e9bbcfc671c6339f519316d7f3586bf52e9adfff2524d9ed7c3efe92", "warmup_time": -1}, "units.time_quantity_init_array": {"code": "def time_quantity_init_array():\n    a * u.m / u.s", "min_run_count": 2, "name": "units.time_quantity_init_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "957f8f9cf4974efcf01e8818e1f02c7f19f8d19c00d1a379e4038026c1a12d44", "warmup_time": -1}, "units.time_quantity_init_scalar": {"code": "def time_quantity_init_scalar():\n    3. * u.m / u.s", "min_run_count": 2, "name": "units.time_quantity_init_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1f7132881f0240f773268d410a62cf9914eff40bd73ad1fd726217c1fb31dc3e", "warmup_time": -1}, "units.time_quantity_init_small_array": {"code": "def time_quantity_init_small_array():\n    \"\"\"\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\n    for small array.\n    \"\"\"\n    b2 * u.m / u.s", "min_run_count": 2, "name": "units.time_quantity_init_small_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e442253d950daa145a563a26e080a23c9196e7b4ed1653d63f04adbbbfc4886a", "warmup_time": -1}, "units.time_quantity_init_small_list": {"code": "def time_quantity_init_small_list():\n    \"\"\"\n    https://github.com/astropy/astropy/issues/7546 reported high overhead\n    for small list.\n    \"\"\"\n    b1 * u.m / u.s", "min_run_count": 2, "name": "units.time_quantity_init_small_list", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "251802d8b8d567ff4a2283a83f7a4c7baa31159203b7efd9ad77ccfd4f150767", "warmup_time": -1}, "units.time_quantity_scalar_conversion": {"code": "def time_quantity_scalar_conversion():\n    (3. * u.m / u.s).to(u.km / u.hour)", "min_run_count": 2, "name": "units.time_quantity_scalar_conversion", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0bc23b508de4b7bbd0fe029aa99741c170acb5975e60e82d95df92c5c4ae0a94", "warmup_time": -1}, "units.time_quantity_times_quantity": {"code": "def time_quantity_times_quantity():\n    q1 * q0", "min_run_count": 2, "name": "units.time_quantity_times_quantity", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "33b450d74c52eb7359c2d056eff45d449f4158a1a0c433bd7a4ab035544b3344", "warmup_time": -1}, "units.time_quantity_times_unit": {"code": "def time_quantity_times_unit():\n    q1 * u.m", "min_run_count": 2, "name": "units.time_quantity_times_unit", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "18101a547d2f59990d20d563f3734a998e00684852452c7778f2425883693063", "warmup_time": -1}, "units.time_quantity_ufunc_sin": {"code": "def time_quantity_ufunc_sin():\n    np.sin(q2)", "min_run_count": 2, "name": "units.time_quantity_ufunc_sin", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6782df2b41ecd8117cefb86c1097ead62fbc89a35d3b19a64b90f3036ea24e15", "warmup_time": -1}, "units.time_quantity_view": {"code": "def time_quantity_view():\n    q1.view(u.Quantity)", "min_run_count": 2, "name": "units.time_quantity_view", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "26ddf3059fc7b8c7c4410ec065066c9f1d29eee90d7da6033ef7fd194dc03c0e", "warmup_time": -1}, "units.time_simple_unit_parse": {"code": "def time_simple_unit_parse():\n    u.Unit('1 d')", "min_run_count": 2, "name": "units.time_simple_unit_parse", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "18937913b36f94725f1c97a07a4783897c64f748e4ca3438d8a366ec405ff794", "warmup_time": -1}, "units.time_unit_compose": {"code": "def time_unit_compose():\n    u.Ry.compose()", "min_run_count": 2, "name": "units.time_unit_compose", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c411870dd43a755992fbca4dc50586233a3eb250670f7ecd6e3861bdc3713d04", "warmup_time": -1}, "units.time_unit_parse": {"code": "def time_unit_parse():\n    u.Unit('1e-07 kg m2 / s2')", "min_run_count": 2, "name": "units.time_unit_parse", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "197b3554fa4d3e39fa3aae6a308abe51ad542092cad5f0868867bc8fa021781f", "warmup_time": -1}, "units.time_unit_to": {"code": "def time_unit_to():\n    u.m.to(u.pc)", "min_run_count": 2, "name": "units.time_unit_to", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6da60807eb0884de058d60357ad655c1d2db3bae2d58d75ddbc21222a2210610", "warmup_time": -1}, "units.time_very_simple_unit_parse": {"code": "def time_very_simple_unit_parse():\n    u.Unit('d')", "min_run_count": 2, "name": "units.time_very_simple_unit_parse", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "21b39993087943b0334e5ed6ac90834c28d709457c414dde5c53f37387b41fdf", "warmup_time": -1}, "visualization.wcsaxes.time_basic_plot": {"code": "def time_basic_plot():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    canvas.draw()", "min_run_count": 2, "name": "visualization.wcsaxes.time_basic_plot", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ec5695860cae34277828c35c0b049fd50bffd8ae413a6e3db7d7f934f1843db", "warmup_time": -1}, "visualization.wcsaxes.time_basic_plot_with_grid": {"code": "def time_basic_plot_with_grid():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.grid(color='red', alpha=0.5, linestyle='solid')\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    canvas.draw()", "min_run_count": 2, "name": "visualization.wcsaxes.time_basic_plot_with_grid", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "27a3a0412eced0052cba10bab2b0ac3f13129808dfac0dc0ebaa1d469475412d", "warmup_time": -1}, "visualization.wcsaxes.time_basic_plot_with_grid_and_overlay": {"code": "def time_basic_plot_with_grid_and_overlay():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.grid(color='red', alpha=0.5, linestyle='solid')\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    overlay = ax.get_coords_overlay('fk5')\n    overlay.grid(color='purple', ls='dotted')\n\n    canvas.draw()", "min_run_count": 2, "name": "visualization.wcsaxes.time_basic_plot_with_grid_and_overlay", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "af06e413366d2baecf8ed41973c1c393c8ac99f49857791375ebbbcd51e9785e", "warmup_time": -1}, "visualization.wcsaxes.time_contour_with_transform": {"code": "def time_contour_with_transform():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.contour(DATA, transform=ax.get_transform(TWOMASS_WCS))\n\n    # The limits are to make sure the contours are in the middle of the result\n    ax.set_xlim(32.5, 150.5)\n    ax.set_ylim(-64.5, 64.5)\n\n    canvas.draw()", "min_run_count": 2, "name": "visualization.wcsaxes.time_contour_with_transform", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "16f5ca0692fab47aedd082450d02be38966127df2778d31fea039005c67c7a92", "warmup_time": -1}, "visualization.wcsaxes.time_contourf_with_transform": {"code": "def time_contourf_with_transform():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.contourf(DATA, transform=ax.get_transform(TWOMASS_WCS))\n\n    # The limits are to make sure the contours are in the middle of the result\n    ax.set_xlim(32.5, 150.5)\n    ax.set_ylim(-64.5, 64.5)\n\n    canvas.draw()", "min_run_count": 2, "name": "visualization.wcsaxes.time_contourf_with_transform", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "94c5584b7804b5ae0e8b922d32d60340b5ccc3b05ff59f0dbd4436f8ebeeff6c", "warmup_time": -1}}, "machines": {"tangra3.stsci.edu": {"arch": "x86_64", "cpu": "Intel(R) Xeon(R) CPU E5-1660 v4 @ 3.20GHz", "machine": "tangra3.stsci.edu", "num_cpu": "16", "os": "Linux 3.10.0-1160.76.1.el7.x86_64", "ram": "32699420", "version": 1}}, "tags": {"0.1": 1845, "v0.1": 1891, "v0.2": 4335, "v0.2.1": 4799, "v0.2.2": 5768, "v0.2.3": 5853, "v0.2.4": 6461, "v0.2.5": 8306, "v0.2b1": 3420, "v0.2b2": 3971, "v0.2rc1": 4271, "v0.3": 8754, "v0.3.1": 10191, "v0.3.2": 11650, "v0.3b1": 8529, "v0.3rc1": 8703, "v0.4": 12840, "v0.4.1": 13202, "v0.4.2": 13777, "v0.4.3": 15736, "v0.4.4": 15866, "v0.4.5": 16354, "v0.4.6": 17323, "v0.4rc1": 12557, "v0.4rc2": 12756, "v0.6": 17970, "v0.7": 21195, "v0.8": 21779, "v0.9": 22431, "v1.0": 16386, "v1.0.1": 16533, "v1.0.10": 22121, "v1.0.11": 23893, "v1.0.12": 24457, "v1.0.13": 25097, "v1.0.2": 16934, "v1.0.3": 17418, "v1.0.4": 18240, "v1.0.5": 19084, "v1.0.6": 19361, "v1.0.7": 19718, "v1.0.8": 19955, "v1.0.9": 20668, "v1.0rc1": 16019, "v1.0rc2": 16319, "v1.1": 19777, "v1.1.1": 19961, "v1.1.2": 20665, "v1.1b1": 19245, "v1.1rc1": 19616, "v1.1rc2": 19742, "v1.2": 22331, "v1.2.1": 22365, "v1.2.2": 23894, "v1.2rc1": 22211, "v1.3": 23895, "v1.3.1": 24494, "v1.3.2": 24606, "v1.3.3": 25102, "v1.3rc1": 23709, "v2.0": 26459, "v2.0.1": 26582, "v2.0.10": 33056, "v2.0.11": 33116, "v2.0.12": 33250, "v2.0.13": 34190, "v2.0.14": 34381, "v2.0.15": 37721, "v2.0.16": 37836, "v2.0.2": 26928, "v2.0.3": 28448, "v2.0.4": 29163, "v2.0.5": 29453, "v2.0.6": 29743, "v2.0.7": 30057, "v2.0.8": 30555, "v2.0.9": 31413, "v2.0rc1": 26281, "v3.0": 29266, "v3.0.1": 29457, "v3.0.2": 29745, "v3.0.3": 30061, "v3.0.4": 30558, "v3.0.5": 31414, "v3.0rc1": 28777, "v3.0rc2": 29020, "v3.1": 33053, "v3.1.1": 33122, "v3.1.2": 33254, "v3.1rc1": 32948, "v3.1rc2": 33013, "v3.2": 34205, "v3.2.1": 34385, "v3.2.2": 37749, "v3.2.3": 37854, "v3.2rc1": 33916, "v3.2rc2": 34138, "v4.0": 38008, "v4.0.1": 38215, "v4.0.1.post1": 38238, "v4.0.2": 40095, "v4.0.3": 40216, "v4.0.4": 40938, "v4.0.5": 41693, "v4.0.6": 43983, "v4.0rc1": 37912, "v4.0rc2": 37981, "v4.1": 40349, "v4.1.dev": 36691, "v4.1rc1": 39087, "v4.1rc2": 39689, "v4.2": 40952, "v4.2.1": 41724, "v4.2.dev": 38891, "v4.2rc1": 40685, "v4.3": 43691, "v4.3.1": 43805, "v4.3.dev": 40538, "v4.3post1": 43693, "v4.3rc1": 43317, "v5.0": 44898, "v5.0.1": 45487, "v5.0.2": 45749, "v5.0.3": 45876, "v5.0.4": 45947, "v5.0.5": 47703, "v5.0.dev": 42948, "v5.0rc1": 44668, "v5.0rc2": 44843, "v5.1": 46507, "v5.1.1": 47737, "v5.1.dev": 44612, "v5.1rc1": 46363, "v5.2": 48279, "v5.2.1": 48532, "v5.2.dev": 46313, "v5.2rc1": 48141, "v5.3.dev": 48026}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}